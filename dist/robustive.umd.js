var P=(s,n,o)=>{if(!n.has(s))throw TypeError("Cannot "+o)};var h=(s,n,o)=>(P(s,n,"read from private field"),o?o.call(s):n.get(s)),b=(s,n,o)=>{if(n.has(s))throw TypeError("Cannot add the same private member more than once");n instanceof WeakSet?n.add(s):n.set(s,o)},T=(s,n,o,w)=>(P(s,n,"write to private field"),w?w.call(s,o):n.set(s,o),o);(function(s,n){typeof exports=="object"&&typeof module!="undefined"?n(exports):typeof define=="function"&&define.amd?define(["exports"],n):(s=typeof globalThis!="undefined"?globalThis:s||self,n(s.Robustive={}))})(this,function(s){var f,y,d;"use strict";class n{constructor(t=null){this.user=t}}class o extends n{}const w=a=>a.constructor===o,v=class{constructor(){return new Proxy(this,{get(t,e,r){switch(e){case"basics":case"alternatives":case"goals":return new Proxy({},{get(i,l,c){return typeof l=="string"&&!(l in i)?u=>Object.freeze({scene:l,course:e,...u}):Reflect.get(i,e,c)}});default:return Reflect.get(t,e,r)}}})}},j={success:"success",failure:"failure"},x=class{constructor(){return new Proxy(this,{get(t,e,r){return typeof e=="string"&&!(e in t)?i=>Object.freeze({type:e,...i}):Reflect.get(t,e,r)}})}};class A{constructor(t,e,r){b(this,f,void 0);b(this,y,void 0);b(this,d,void 0);T(this,f,t),T(this,y,e),T(this,d,r)}interactedBy(t){const e=new Date,r=new x,i=c=>{const u=c.slice(-1)[0];return u.course==="goals"?Promise.resolve(c):h(this,d).next(u).then(g=>(c.push(g),i(c)))};if(h(this,d).authorize&&!h(this,d).authorize(t,h(this,f))){const c=new R(t.constructor.name,h(this,f));return Promise.reject(c)}const l=[h(this,y)];return i(l).then(c=>{const u=new Date,g=u.getTime()-e.getTime(),S=c.slice(-1)[0];return r.success({actor:t,usecase:h(this,f),startAt:e,endAt:u,elapsedTimeMs:g,performedScenario:c,lastSceneContext:S})}).catch(c=>{console.error(c);const u=new Date,g=u.getTime()-e.getTime();return r.failure({actor:t,usecase:h(this,f),startAt:e,endAt:u,elapsedTimeMs:g,error:c})})}}f=new WeakMap,y=new WeakMap,d=new WeakMap;const m=class{constructor(t,e,r){return new Proxy(this,{get(i,l,c){return typeof l=="string"&&!(l in i)?u=>{const g={scene:l,course:e,...u},S=new A(t,g,new r);return Object.freeze(Object.assign(S,{name:t}))}:Reflect.get(i,l,c)}})}};class I{constructor(){const{basics:t,alternatives:e,goals:r}=new v;this.basics=t,this.alternatives=e,this.goals=r}just(t){return Promise.resolve(t)}}class z{constructor(t,e){this.basics=new m(t,"basics",e),this.alternatives=new m(t,"alternatives",e),this.goals=new m(t,"goals",e)}}const C=class{constructor(){return new Proxy(this,{get(t,e,r){return typeof e=="string"&&!(e in t)?i=>new z(e,i):Reflect.get(t,e,r)}})}};class R extends Error{constructor(t,e){super(`The actor "${t}" is not authorized to interact on usecase "${e}".`),Object.setPrototypeOf(this,new.target.prototype)}}s.ActorNotAuthorizedToInteractIn=R,s.BaseActor=n,s.BaseScenario=I,s.ContextSelector=v,s.InteractResultType=j,s.Nobody=o,s.UsecaseSelector=C,s.isNobody=w,Object.defineProperties(s,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
