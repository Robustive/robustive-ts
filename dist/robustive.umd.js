var I=(n,a,h)=>{if(!a.has(n))throw TypeError("Cannot "+h)};var c=(n,a,h)=>(I(n,a,"read from private field"),h?h.call(n):a.get(n)),S=(n,a,h)=>{if(a.has(n))throw TypeError("Cannot add the same private member more than once");a instanceof WeakSet?a.add(n):a.set(n,h)},v=(n,a,h,R)=>(I(n,a,"write to private field"),R?R.call(n,h):a.set(n,h),h);(function(n,a){typeof exports=="object"&&typeof module!="undefined"?a(exports):typeof define=="function"&&define.amd?define(["exports"],a):(n=typeof globalThis!="undefined"?globalThis:n||self,a(n.Robustive={}))})(this,function(n){var d,g,b,l;"use strict";class a{constructor(e=null){this.user=e}}class h extends a{}const R=u=>u.constructor===h,j=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?t:Reflect.get(e,t,s)}})}},A=class{constructor(e){return new Proxy(this,{get(t,s,i){return typeof s=="string"&&!(s in t)?r=>Object.freeze(Object.assign(r||{},{scene:s,course:e})):Reflect.get(t,s,i)}})}},O=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?t:Reflect.get(e,t,s)}})}},F={success:"success",failure:"failure"},C=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?i=>Object.freeze(Object.assign(i,{type:t})):Reflect.get(e,t,s)}})}},E=u=>{const e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";return Array.from(crypto.getRandomValues(new Uint8Array(u))).map(t=>e[t%e.length]).join("")};class N{constructor(e,t,s,i,r){S(this,d,void 0);S(this,g,void 0);S(this,b,void 0);S(this,l,void 0);this.id=e,v(this,d,t),v(this,g,s),v(this,b,i),v(this,l,r)}set(e){c(this,l).delegate=e}progress(e){if(c(this,l).authorize&&!c(this,l).authorize(e,c(this,d),c(this,g))){const t=new x(e,c(this,d),c(this,g));return Promise.reject(t)}return c(this,l).next(c(this,b))}interactedBy(e){const t=new Date,s=new C,i=o=>{const f=o.slice(-1)[0];return f.course==="goals"?Promise.resolve(o):c(this,l).next(f).then(y=>(o.push(y),i(o)))};if(c(this,l).authorize&&!c(this,l).authorize(e,c(this,d),c(this,g))){const o=new x(e,c(this,d),c(this,g));return Promise.reject(o)}const r=[c(this,b)];return i(r).then(o=>{const f=new Date,y=f.getTime()-t.getTime(),m=o.slice(-1)[0],w=s.success({id:this.id,actor:e,domain:c(this,d),usecase:c(this,g),startAt:t,endAt:f,elapsedTimeMs:y,performedScenario:o,lastSceneContext:m});return c(this,l).complete&&c(this,l).complete(w),w}).catch(o=>{console.error(o);const f=new Date,y=f.getTime()-t.getTime(),m=r.slice(-1)[0],w=s.failure({id:this.id,actor:e,domain:c(this,d),usecase:c(this,g),startAt:t,endAt:f,elapsedTimeMs:y,performedScenario:r,failedSceneContext:m,error:o});return c(this,l).complete&&c(this,l).complete(w),w})}}d=new WeakMap,g=new WeakMap,b=new WeakMap,l=new WeakMap;const T=class{constructor(e,t,s,i){return new Proxy(this,{get(r,o,f){return typeof o=="string"&&!(o in r)?(y,m,w=!1)=>{const $=Object.assign(y||{},{scene:o,course:s}),P=m||E(8),_=new i(e,t,P,w),K=new N(P,e,t,$,_);return Object.freeze(Object.assign(K,{domain:e,name:t,scene:o,course:s}))}:Reflect.get(r,o,f)}})}};class U{constructor(e,t,s){this.keys={basics:new O,alternatives:new O,goals:new O},this.basics=new T(e,t,"basics",s),this.alternatives=new T(e,t,"alternatives",s),this.goals=new T(e,t,"goals",s)}}class k{constructor(e,t,s,i=!1){this.domain=e,this.usecase=t,this.id=s,this.isSubstitute=i,this.keys={basics:new j,alternatives:new j,goals:new j},this.basics=new A("basics"),this.alternatives=new A("alternatives"),this.goals=new A("goals")}next(e){if(this.delegate!==void 0&&this.delegate.next!==void 0)return this.delegate.next(e,this);throw new Error}just(e){return Promise.resolve(e)}authorize(e,t,s){if(this.delegate!==void 0&&this.delegate.authorize!==void 0)return this.delegate.authorize(e,t,s);throw new Error(`USECASE "${s}" IS NOT AUTHORIZED FOR ACTOR "${e.constructor.name}."`)}complete(e){this.delegate!==void 0&&this.delegate.complete!==void 0&&this.delegate.complete(e)}}const z=class{constructor(e,t){const s=Object.keys(t);return this.keys=s.reduce((i,r)=>(i[r]=r,i),{}),new Proxy(this,{get(i,r,o){return typeof r=="string"&&s.includes(r)?new U(e,r,t[r]):Reflect.get(i,r,o)}})}},D=class{constructor(e){const t=Object.keys(e);return this.keys=t.reduce((s,i)=>(s[i]=i,s),{}),new Proxy(this,{get(s,i,r){return typeof i=="string"&&t.includes(i)?new z(i,e[i]):Reflect.get(s,i,r)}})}};class x extends Error{constructor(e,t,s){super(`The actor "${e.constructor.name}" is not authorized to interact on usecase "${String(s)}" of domain "${String(t)}".`)}}const M=class{constructor(e){return new Proxy(this,{get(t,s,i){return typeof s=="string"&&!(s in t)?r=>Object.freeze(e!==void 0?Object.assign(new e,Object.assign(r||{},{case:s})):Object.assign(r||{},{case:s})):Reflect.get(t,s,i)}})}};n.AbstractActor=a,n.AbstractScenario=k,n.ActorNotAuthorizedToInteractIn=x,n.InteractResultType=F,n.Nobody=h,n.Robustive=D,n.SwiftEnum=M,n.UsecaseSelector=z,n.isNobody=R,Object.defineProperties(n,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
