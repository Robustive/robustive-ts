var j=(s,c,o)=>{if(!c.has(s))throw TypeError("Cannot "+o)};var l=(s,c,o)=>(j(s,c,"read from private field"),o?o.call(s):c.get(s)),b=(s,c,o)=>{if(c.has(s))throw TypeError("Cannot add the same private member more than once");c instanceof WeakSet?c.add(s):c.set(s,o)},m=(s,c,o,S)=>(j(s,c,"write to private field"),S?S.call(s,o):c.set(s,o),o);(function(s,c){typeof exports=="object"&&typeof module!="undefined"?c(exports):typeof define=="function"&&define.amd?define(["exports"],c):(s=typeof globalThis!="undefined"?globalThis:s||self,c(s.Robustive={}))})(this,function(s){var d,f,w,g;"use strict";class c{constructor(t=null){this.user=t}}class o extends c{}const S=u=>u.constructor===o,R=class{constructor(){return new Proxy(this,{get(t,e,n){switch(e){case"basics":case"alternatives":case"goals":return new Proxy({},{get(i,h,r){return typeof h=="string"&&!(h in i)?a=>Object.freeze({scene:h,course:e,...a}):Reflect.get(i,e,r)}});default:return Reflect.get(t,e,n)}}})}},x={success:"success",failure:"failure"},A=class{constructor(){return new Proxy(this,{get(t,e,n){return typeof e=="string"&&!(e in t)?i=>Object.freeze({type:e,...i}):Reflect.get(t,e,n)}})}};class C{constructor(t,e,n,i){b(this,d,void 0);b(this,f,void 0);b(this,w,void 0);b(this,g,void 0);m(this,d,t),m(this,f,e),m(this,w,n),m(this,g,i)}interactedBy(t){const e=new Date,n=new A,i=r=>{const a=r.slice(-1)[0];return a.course==="goals"?Promise.resolve(r):l(this,g).next(a).then(y=>(r.push(y),i(r)))};if(l(this,g).authorize&&!l(this,g).authorize(t,l(this,d),l(this,f))){const r=new O(t.constructor.name,l(this,f));return Promise.reject(r)}const h=[l(this,w)];return i(h).then(r=>{const a=new Date,y=a.getTime()-e.getTime(),T=r.slice(-1)[0];return n.success({domain:l(this,d),actor:t,usecase:l(this,f),startAt:e,endAt:a,elapsedTimeMs:y,performedScenario:r,lastSceneContext:T})}).catch(r=>{console.error(r);const a=new Date,y=a.getTime()-e.getTime();return n.failure({domain:l(this,d),actor:t,usecase:l(this,f),startAt:e,endAt:a,elapsedTimeMs:y,error:r})})}}d=new WeakMap,f=new WeakMap,w=new WeakMap,g=new WeakMap;const v=class{constructor(t,e,n,i){return new Proxy(this,{get(h,r,a){return typeof r=="string"&&!(r in h)?y=>{const T={scene:r,course:n,...y},D=new C(t,e,T,new i);return Object.freeze(Object.assign(D,{name:e,domain:t}))}:Reflect.get(h,r,a)}})}};class I{constructor(){const{basics:t,alternatives:e,goals:n}=new R;this.basics=t,this.alternatives=e,this.goals=n}just(t){return Promise.resolve(t)}}class z{constructor(t,e,n){this.basics=new v(t,e,"basics",n),this.alternatives=new v(t,e,"alternatives",n),this.goals=new v(t,e,"goals",n)}}const P=class{constructor(t){return new Proxy(this,{get(e,n,i){return typeof n=="string"&&!(n in e)?h=>new z(t,n,h):Reflect.get(e,n,i)}})}},U=class{constructor(){return new Proxy(this,{get(t,e,n){return typeof e=="string"&&!(e in t)?new P(e):Reflect.get(t,e,n)}})}};class O extends Error{constructor(t,e){super(`The actor "${t}" is not authorized to interact on usecase "${e}".`),Object.setPrototypeOf(this,new.target.prototype)}}s.ActorNotAuthorizedToInteractIn=O,s.BaseActor=c,s.BaseScenario=I,s.ContextSelector=R,s.InteractResultType=x,s.Nobody=o,s.UsecaseSelector=P,s.UsecaseSelectorOverDomain=U,s.isNobody=S,Object.defineProperties(s,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
