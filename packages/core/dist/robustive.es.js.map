{"version":3,"file":"robustive.es.js","sources":["../src/actor.ts","../src/usecase.ts","../src/enum.ts"],"sourcesContent":["import { DomainRequirements } from \"./usecase\";\n\nexport interface IActor<User> {\n    user: User | null;\n    isAuthorizedTo?: <R extends DomainRequirements>(domain: keyof R, usecase: keyof R[keyof R]) => boolean\n}\n\nexport abstract class AbstractActor<User> implements IActor<User> {\n    user: User | null;\n    constructor(user: User | null = null) {\n        this.user = user;\n    }\n\n    abstract isAuthorizedTo?: <R extends DomainRequirements>(domain: keyof R, usecase: keyof R[keyof R]) => boolean\n}\n\nexport class Nobody extends AbstractActor<null> {\n    isAuthorizedTo?: (<R extends DomainRequirements>(domain: keyof R, usecase: keyof R[keyof R]) => boolean) | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isNobody = (actor: any): actor is Nobody => actor.constructor === Nobody;\n","import { IActor } from \"./actor\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type NOCARE = any;\n\ntype PreFlatten<Z> = {\n    [C in keyof Z as C extends string \n        ? Z[C] extends Empty // for empty alternatives\n            ? never\n            : `${C}.${keyof Z[C] & string}`\n        : C\n    ] : Z[C];\n};\n\ntype Flatten<Z> = {\n    [CK in keyof PreFlatten<Z>] : CK extends `${infer C extends keyof Z & string}.${string}`\n        ? CK extends `${string}.${infer K extends keyof Z[C] & string}`\n            ? Z[C][K] \n            : never\n        : never;\n};\n\nconst courses = [\"basics\", \"alternatives\", \"goals\"] as const;\nexport type Courses = typeof courses[number];\ntype Basics = Extract<Courses, \"basics\">;\ntype Alternatives = Extract<Courses, \"alternatives\">;\ntype Goals = Extract<Courses, \"goals\">;\n\ntype ContextualValues = Record<string, object>;\nexport type Empty = Record<string, never>;\n\nexport type Scenes = {\n    basics: ContextualValues;\n    alternatives: ContextualValues;\n    goals: ContextualValues;\n};\n\n// Convert Scenes into Discriminated Union like { scene: \"...\", ... }\nexport type Context<Z extends Scenes> = {\n    readonly [K in keyof Flatten<Z>]: K extends `${ infer C }.${ infer S }` \n        ? Flatten<Z>[K] extends Empty\n            ? { scene: S; course: C; }\n            : { scene: S; course: C; } & Flatten<Z>[K]\n        : never \n}[keyof Flatten<Z>];\n\nexport type ContextOf<Z extends Scenes, C extends Courses> = {\n    readonly [S in keyof Z[C]]:\n        Z[C][S] extends Empty\n            ? { scene: S; course: C; }\n            : { scene: S; course: C; } & Z[C][S]\n}[keyof Z[C]];\n\ntype SceneFactory<Z extends Scenes, C extends Courses> = Z[C] extends Empty\n    ? Empty // for empty alternatives\n    : { \n        [K in keyof Z[C]]: K\n    };\n\nconst SceneFactory = class SceneFactory {\n    constructor() {\n        return new Proxy(this, {\n            get(target, prop, receiver) { // prop = scene\n                return ((typeof prop === \"string\") && !(prop in target))\n                    ? prop\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <Z extends Scenes, C extends Courses>() => SceneFactory<Z, C>;\n    \ntype ContextFactory<Z extends Scenes, C extends Courses> = Z[C] extends Empty\n    ? Empty // for empty alternatives\n    : { \n        [K in keyof Z[C]]: Z[C][K] extends Empty\n            ? () => Context<Z>\n            : (withValues: Z[C][K]) => Context<Z>\n    };\n\n/**\n * The context factory held by the scenario instance passed as an argument \n * to the next function of ScenarioDelegate, which is called during the execution\n * of a usecase scenario. This is used to create the context for the next scene.\n */\nconst ContextFactory = class ContextFactory<C extends Courses> {\n    constructor(course: C) {\n        return new Proxy(this, {\n            get(target, prop, receiver) { // prop = scene\n                return ((typeof prop === \"string\") && !(prop in target))\n                    ? (withValues?: ContextualValues) => {\n                        return Object.freeze(Object.assign(withValues || {}, { \"scene\" : prop, course }));\n                    }\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <Z extends Scenes, C extends Courses>(course: C) => ContextFactory<Z, C>;\n\ntype UsecaseScenarios<D extends string> = { [U in string] : new (domain: D, usecase: U, id: string, isSubstitute: boolean) => Scenario<NOCARE> };\nexport type DomainRequirements = { [D in string] :  UsecaseScenarios<D> };\n\ntype DomainKeys<R extends DomainRequirements> = {\n    [D in keyof R]: D\n};\n\ntype UsecaseKeys<R extends DomainRequirements, D extends keyof R> = {\n    [U in keyof R[D]]: U\n};\n\nexport type InferScenes<R extends DomainRequirements, D extends keyof R, U extends keyof R[D]> = {\n  [U in keyof R[D]]: R[D][U] extends {\n    new (domain: string, usecase: string, id: string, isSubstitute?: boolean): Scenario<infer Z extends Scenes>\n  }\n    ? Z\n    : never\n}[U];\n\ntype SceneFactoryAdapter<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], C extends Courses> = InferScenes<R, D, U>[C] extends Empty\n    ? Empty // for Empty alternative\n    : SceneFactory<InferScenes<R, D, U>, C>;\n\nconst SceneFactoryAdapter = class SceneFactoryAdapter {\n    constructor() {\n        return new Proxy(this, {\n            get(target, prop, receiver) { // prop = scene\n                return ((typeof prop === \"string\") && !(prop in target))\n                    ? prop\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <R extends DomainRequirements, D extends keyof R, U extends keyof R[D], C extends Courses>() => SceneFactoryAdapter<R, D, U, C>;\n\nexport type StringKeyof<T> = Extract<keyof T, string>;\n\n// export type InferScenesInScenario<T> = T extends Scenario<infer Z extends Scenes> ? Z : never;\n\nexport interface IScenarioDelegate<Z extends Scenes> {\n    next?<A extends IActor<NOCARE>, S extends Scenario<Z>>(to: Context<Z>, actor: A, scenario: S): Promise<Context<Z>>;\n    authorize?<A extends IActor<NOCARE>, R extends DomainRequirements, D extends StringKeyof<R>, U extends StringKeyof<R[D]>>(actor: A, domain: D, usecase: U): boolean;\n    complete?<A extends IActor<NOCARE>, R extends DomainRequirements, D extends keyof R, U extends keyof R[D]>(withResult: InteractResult<R, D, U, A, Z>): void;\n}\n\n\n// for declaring like \"SomeScenario<SomeScenes>\", cannot use generics parameters \"D extends UsecaseDefinitions, U extends keyof D\"\nexport class Scenario<Z extends Scenes> {\n    readonly domain: string;\n    readonly usecase: string;\n    readonly id: string;\n    readonly isSubstitute: boolean;\n    delegate?: IScenarioDelegate<Z>;\n    readonly keys: {\n        readonly basics : SceneFactory<Z, Basics>;\n        readonly alternatives : SceneFactory<Z, Alternatives>;\n        readonly goals : SceneFactory<Z, Goals>;\n    };\n    readonly basics: ContextFactory<Z, Basics>;\n    readonly alternatives: ContextFactory<Z, Alternatives>;\n    readonly goals: ContextFactory<Z, Goals>;\n\n    constructor(domain: string, usecase: string, id: string, isSubstitute = false) {\n        this.domain = domain;\n        this.usecase = usecase;\n        this.id = id;\n        this.isSubstitute = isSubstitute;\n        this.keys = {\n            basics: new SceneFactory<Z, Basics>()\n            , alternatives: new SceneFactory<Z, Alternatives>()\n            , goals: new SceneFactory<Z, Goals>()\n        };\n        this.basics = new ContextFactory<Z, Basics>(\"basics\");\n        this.alternatives = new ContextFactory<Z, Alternatives>(\"alternatives\");\n        this.goals = new ContextFactory<Z, Goals>(\"goals\");\n    }\n\n    next<A extends IActor<NOCARE>>(to: Context<Z>, actor: A): Promise<Context<Z>> {\n        if (this.delegate !== undefined && this.delegate.next !== undefined) {\n            return this.delegate.next(to, actor, this);\n        }\n        return Promise.reject(new Error());\n    }\n    \n    just(next: Context<Z>) : Promise<Context<Z>> {\n        return Promise.resolve(next);\n    }\n\n    authorize<A extends IActor<NOCARE>, R extends DomainRequirements, D extends StringKeyof<R>, U extends StringKeyof<R[D]>>(actor: A, domain: D, usecase: U): boolean {\n        if (this.delegate !== undefined && this.delegate.authorize !== undefined) {\n            return this.delegate.authorize(actor, domain, usecase);\n        }\n        throw new Error(`USECASE \"${usecase}\" IS NOT AUTHORIZED FOR ACTOR \"${actor.constructor.name}.\"`);\n    }\n\n    complete<A extends IActor<NOCARE>, R extends DomainRequirements, D extends keyof R, U extends keyof R[D]>(withResult: InteractResult<R, D, U, A, Z>): void {\n        if (this.delegate !== undefined && this.delegate.complete !== undefined) {\n            this.delegate.complete(withResult);\n        }\n    }\n}\n\nexport const InteractResultType = {\n    success: \"success\"\n    , failure: \"failure\"\n} as const;\n\ntype InteractResultContext<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends Scenes> = {\n    [InteractResultType.success] : {\n        id: string;\n        actor : A;\n        domain : D;\n        usecase : U;\n        startAt : Date;\n        endAt : Date;\n        elapsedTimeMs : number;\n        performedScenario : Context<Z>[];\n        lastSceneContext : ContextOf<Z, \"goals\">;\n    };\n    [InteractResultType.failure] : {\n        id: string;\n        actor : A;\n        domain : D;\n        usecase : U;\n        startAt : Date;\n        endAt : Date;\n        elapsedTimeMs : number;\n        performedScenario : Context<Z>[];\n        failedSceneContext : Context<Z>;\n        error: Error;\n    };\n};\n\ntype InteractResultCase<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends Scenes, K extends keyof InteractResultContext<R, D, U, A, Z>> = Record<\"type\", K> & InteractResultContext<R, D, U, A, Z>[K];\n\nexport type InteractResult<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends Scenes> = { \n    [K in keyof InteractResultContext<R, D, U, A, Z>] : InteractResultCase<R, D, U, A, Z, K>;\n}[keyof InteractResultContext<R, D, U, A, Z>];\n\n\ntype InteractResultSelector<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends Scenes> = { \n    [K in keyof InteractResultContext<R, D, U, A, Z>] : (withValues: InteractResultContext<R, D, U, A, Z>[K]) => InteractResultCase<R, D, U, A, Z, K>;\n};\n\nconst InteractResultFactory = class InteractResultFactory {\n    constructor() {\n        return new Proxy(this, {\n            get(target, prop, receiver) {\n                return ((typeof prop === \"string\") && !(prop in target))\n                    ? (withValues: object) => {\n                        return Object.freeze(Object.assign(withValues, { \"type\" : prop }));\n                    }\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends InferScenes<R, D, U>>() => InteractResultSelector<R, D, U, A, Z>;\n\nconst generateId = (length: number) => { \n    const S = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; \n    return Array.from(crypto.getRandomValues(new Uint8Array(length))).map((n)=>S[n%S.length]).join(\"\");\n};\n\n// Manage currentContext with WeakMap because UsecaseImple instances are frozen.\nconst currentContextStore = new WeakMap<object, NOCARE>();\n\nexport class UsecaseImple<R extends DomainRequirements, D extends keyof R, U extends keyof R[D]> {\n    readonly id: string;\n    private readonly _domain: D;\n    private readonly _usecase: U;\n    private readonly _scenario: Scenario<InferScenes<R, D, U>>;\n\n    constructor(id: string, domain: D, usecase: U, initialContext: Context<InferScenes<R, D, U>>, scenario: Scenario<InferScenes<R, D, U>>) {\n        this.id = id;\n        this._domain = domain;\n        this._usecase = usecase;\n        this._scenario = scenario;\n        currentContextStore.set(this, initialContext);\n    }\n\n    get currentContext(): Context<InferScenes<R, D, U>> {\n        return currentContextStore.get(this);\n    }\n\n    set currentContext(context: Context<InferScenes<R, D, U>>) {\n        currentContextStore.set(this, context);\n    }\n\n    set(delegate: IScenarioDelegate<InferScenes<R, D, U>>): void {\n        this._scenario.delegate = delegate;\n    }\n\n    /**\n     * Step through the usecase scenario from the current scene to the next scene.\n     * @param actor \n     * @returns \n     */\n    progress<User, A extends IActor<User>>(actor: A): Promise<Context<InferScenes<R, D, U>>> {\n        if (this._scenario.authorize && !this._scenario.authorize(actor, this._domain as Extract<D, string>, this._usecase as Extract<U, string>)) {\n            const err = new ActorNotAuthorizedToInteractIn(actor, this._domain, this._usecase);\n            return Promise.reject(err);\n        }\n        return this._scenario.next(this.currentContext, actor)\n            .then(nextScene => {\n                this.currentContext = nextScene;\n                return nextScene;\n            });\n    }\n\n    /**\n     * Execute the use case to completion according to the defined scenario.\n     * @param actor \n     * @returns \n     */\n    interactedBy<User, A extends IActor<User>>(actor: A): Promise<InteractResult<R, D, U, A, InferScenes<R, D, U>>> {\n        const startAt = new Date();\n        const InteractResult = new InteractResultFactory<R, D, U, A, InferScenes<R, D, U>>();\n\n        const recursive = (scenario: Context<InferScenes<R, D, U>>[]): Promise<Context<InferScenes<R, D, U>>[]> => {\n            const lastScene = scenario.slice(-1)[0];\n            if (lastScene.course === \"goals\") { // exit criteria\n                return Promise.resolve(scenario);\n            }\n\n            return this._scenario.next(lastScene, actor)\n                .then((nextScene) => {\n                    this.currentContext = nextScene;\n                    scenario.push(nextScene);\n                    return recursive(scenario);\n                });\n        };\n\n        if (this._scenario.authorize && !this._scenario.authorize(actor, this._domain as Extract<D, string>, this._usecase as Extract<U, string>)) {\n            const err = new ActorNotAuthorizedToInteractIn(actor, this._domain, this._usecase);\n            return Promise.reject(err);\n        }\n        const scenario: Context<InferScenes<R, D, U>>[] = [this.currentContext];\n        return recursive(scenario)\n            .then((performedScenario) => {\n                const endAt = new Date();\n                const elapsedTimeMs = (endAt.getTime() - startAt.getTime());\n                const lastSceneContext = performedScenario.slice(-1)[0] as ContextOf<InferScenes<R, D, U>, \"goals\">;\n                const result = InteractResult.success({\n                    id: this.id\n                    , actor\n                    , domain: this._domain\n                    , usecase : this._usecase\n                    , startAt\n                    , endAt\n                    , elapsedTimeMs\n                    , performedScenario\n                    , lastSceneContext\n                });\n                if (this._scenario.complete) { this._scenario.complete(result); }\n                return result;\n            })\n            .catch((err) => {\n                console.error(err);\n                const endAt = new Date();\n                const elapsedTimeMs = (endAt.getTime() - startAt.getTime());\n                const lastSceneContext = scenario.slice(-1)[0];\n                const result =  InteractResult.failure({\n                    id: this.id\n                    , actor\n                    , domain: this._domain\n                    , usecase : this._usecase\n                    , startAt\n                    , endAt\n                    , elapsedTimeMs\n                    , performedScenario : scenario\n                    , failedSceneContext : lastSceneContext\n                    , error : err\n                });\n                if (this._scenario.complete) { this._scenario.complete(result); }\n                return result;\n            });\n    }\n}\n\ntype UsecaseContext<R extends DomainRequirements, D extends keyof R, U extends keyof R[D]>  = {\n    \"domain\": D;\n    \"name\" : U; // The property name is name instead of usecase because it is assumed that it will be used as usecase.name when used.\n    \"course\": Courses;\n    \"scene\": string;\n}\n\nexport type Usecase<R extends DomainRequirements, D extends keyof R, U extends keyof R[D]> = UsecaseContext<R, D, U> & UsecaseImple<R, D, U>;\n\n// for making usecase as Discriminated Union, must use \"keyof D\" for type of name, not use \"string\".\ntype ScenarioFactory<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], C extends Courses> = InferScenes<R, D, U>[C] extends Empty\n    ? Empty // for Empty alternative\n    : {\n        [K in keyof InferScenes<R, D, U>[C]]: InferScenes<R, D, U>[C][K] extends Empty\n            ? (id?: string, isSubstitute?: boolean) => Usecase<R, D, U>\n            : (withValues: InferScenes<R, D, U>[C][K], id?: string, isSubstitute?: boolean) => Usecase<R, D, U>\n    };\n\n/**\n * The scenario factory invoked via the UsecaseSelector and CourseSelector\n * held by the Robustive instance. This is used to create an instance of the usecase\n * to be executed.\n */\nconst ScenarioFactory = class ScenarioFactory<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], C extends Courses> {\n    constructor(domain: D, usecase: U, course: C, scenario: new (domain: D, usecase: U, id: string, isSubstitute: boolean) => Scenario<InferScenes<R, D, U>>) {\n        return new Proxy(this, {\n            get(target, prop, receiver) {\n                return ((typeof prop === \"string\") && !(prop in target))\n                    ? (withValues?: ContextualValues, id?: string, isSubstitute = false) => {\n                        const context = Object.assign(withValues || {}, { \"scene\" : prop, course }) as unknown as Context<InferScenes<R, D, U>>;\n                        const _id = id || generateId(8);\n                        const s = new scenario(domain, usecase, _id, isSubstitute);\n                        const usecaseImple = new UsecaseImple<R, D, U>(_id, domain, usecase, context, s);\n                        return Object.freeze(Object.assign(usecaseImple, { \"domain\": domain, \"name\" : usecase, \"scene\": prop, course }));\n                    }\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <R extends DomainRequirements, D extends keyof R, U extends keyof R[D], C extends Courses>(domain: D, usecase: U, course: C, scenario: new (domain: D, usecase: U, id: string, isSubstitute: boolean) => Scenario<InferScenes<R, D, U>>) => ScenarioFactory<R, D, U, C>;\n\nexport class CourseSelector<R extends DomainRequirements, D extends keyof R, U extends keyof R[D]> {\n    readonly keys: {\n        readonly basics : SceneFactoryAdapter<R, D, U, Basics>;\n        readonly alternatives : SceneFactoryAdapter<R, D, U, Alternatives>;\n        readonly goals : SceneFactoryAdapter<R, D, U, Goals>;\n    };\n    readonly basics: ScenarioFactory<R, D, U, Basics>;\n    readonly alternatives: ScenarioFactory<R, D, U, Alternatives>;\n    readonly goals: ScenarioFactory<R, D, U, Goals>;\n\n    constructor(domain: D, usecase: U, scenario: new (domain: D, usecase: U, id: string, isSubstitute: boolean) => Scenario<InferScenes<R, D, U>>) {\n        this.keys = {\n            basics: new SceneFactoryAdapter<R, D, U, Basics>()\n            , alternatives: new SceneFactoryAdapter<R, D, U, Alternatives>()\n            , goals: new SceneFactoryAdapter<R, D, U, Goals>()\n        };\n        this.basics = new ScenarioFactory<R, D, U, Basics>(domain, usecase, \"basics\", scenario);\n        this.alternatives = new ScenarioFactory<R, D, U, Alternatives>(domain, usecase, \"alternatives\", scenario);\n        this.goals = new ScenarioFactory<R, D, U, Goals>(domain, usecase, \"goals\", scenario);\n    }\n}\n\nexport type UsecaseSelector<R extends DomainRequirements, D extends StringKeyof<R>> = Record<\"keys\", UsecaseKeys<R, D>> & { \n    [U in keyof R[D]]: CourseSelector<R, D, U>\n};\n\nexport const UsecaseSelector = class UsecaseSelector<R extends DomainRequirements, D extends StringKeyof<R>> {\n    readonly keys: UsecaseKeys<R, D>;\n    constructor(domain: D, scenarioConstructors: UsecaseScenarios<D>) {\n        const usecaseKeys = Object.keys(scenarioConstructors);\n        this.keys = usecaseKeys.reduce<Record<string, string>>((keys, usecase) => {\n            keys[usecase] = usecase;\n            return keys;\n        }, {}) as UsecaseKeys<R, D>;\n        return new Proxy(this, {\n            get(target, prop, receiver) { // prop = usecase\n                return ((typeof prop === \"string\") && usecaseKeys.includes(prop))\n                    ? new CourseSelector<R, D, StringKeyof<UsecaseScenarios<D>>>(domain, prop, scenarioConstructors[prop])\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <R extends DomainRequirements, D extends StringKeyof<R>>(domain: D, scenarioConstructors: UsecaseScenarios<D>) => UsecaseSelector<R, D>;\n\nexport type Robustive<R extends DomainRequirements> = Record<\"keys\", DomainKeys<R>> & {\n    [D in StringKeyof<R>] : UsecaseSelector<R, D>;\n};\n\nexport const Robustive = class Robustive<R extends DomainRequirements> {\n    readonly keys: DomainKeys<R>;\n    constructor(requirements: R) {\n        const domainKeys = Object.keys(requirements);\n        this.keys = domainKeys.reduce<Record<string, string>>((keys, domain) => {\n            keys[domain] = domain;\n            return keys;\n        }, {}) as DomainKeys<R>;\n        return new Proxy(this, {\n            get(target, prop, receiver) { // prop = domain\n                return ((typeof prop === \"string\") && domainKeys.includes(prop))\n                    ? new UsecaseSelector<R, StringKeyof<R>>(prop as StringKeyof<R>, requirements[prop])\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <R extends DomainRequirements>(requirements: R) => Robustive<R>;\n\nexport type AllUsecases<R extends DomainRequirements, D extends keyof R> = {\n    [U in keyof R[D]] : Usecase<R, D, U>\n}[keyof R[D]];\n\nexport type AllUsecasesOverDomain<R extends DomainRequirements> = {\n    [D in keyof R] : {\n        [U in keyof R[D]] : Usecase<R, D, U>\n    }[keyof R[D]]\n}[keyof R];\n\nexport class ActorNotAuthorizedToInteractIn<A extends IActor<NOCARE>, Domain, Usecase> extends Error {\n    constructor(actor: A, domain: Domain, usecase: Usecase) {\n        super(`The actor \"${ actor.constructor.name }\" is not authorized to interact on usecase \"${ String(usecase) }\" of domain \"${ String(domain) }\".`);\n    }\n}","import { Empty } from \"./usecase\";\n\ntype CaseWithAssociatedValues = Record<string, object>\n\ntype KeyFactory<T extends CaseWithAssociatedValues> = {\n    [K in keyof T]: K\n}\n\nconst KeyFactory = class KeyFactory {\n    constructor() {\n        return new Proxy(this, {\n            get(target, prop, receiver) { // prop = scene\n                return ((typeof prop === \"string\") && !(prop in target))\n                    ? prop\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <T extends CaseWithAssociatedValues>() => KeyFactory<T>;\n  \n\ntype SwiftEnumCase<T extends CaseWithAssociatedValues, K extends keyof T, U > = U & (T[K] extends Empty ? { readonly case: K } : { readonly case: K } & T[K])\n\nexport type SwiftEnumCases<T extends CaseWithAssociatedValues, U = Empty> = {\n    readonly [K in keyof T]: SwiftEnumCase<T, K, U>\n}[keyof T]\n\nexport type SwiftEnum<T extends CaseWithAssociatedValues, U> = {\n    [K in keyof T]: T[K] extends Empty\n        ? () => SwiftEnumCase<T, K, U>\n        : (associatedValues: T[K]) => SwiftEnumCase<T, K, U>\n} & { keys: KeyFactory<T> }\n\nexport const SwiftEnum = class SwiftEnum<T extends CaseWithAssociatedValues, U extends Object> {\n    keys: KeyFactory<T>;\n    constructor(f?: new () => U) {\n        this.keys = new KeyFactory<T>();\n        return new Proxy(this, {\n            get(target, prop, receiver) {\n                return typeof prop === \"string\" && !(prop in target)\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    ? (associatedValues?: any) =>\n                        f !== undefined\n                            /**\n                             * note: Thereâ€™s room for discussion on whether to restrict associatedValues \n                             * to an Object and use `{ ...associatedValues }`, or to allow class instances \n                             * by using `associatedValues || {}`.\n                             * The former eliminates the risk of mutating the original reference, \n                             * but at the cost of losing the flexibility to pass in instances.\n                             */\n                            ? Object.freeze(Object.assign(new f(), Object.assign(associatedValues || {}, { case: prop })))\n                            : Object.freeze(Object.assign(associatedValues || {}, { case: prop }))\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <T extends CaseWithAssociatedValues, U = Empty>(\n    f?: new () => U\n) => SwiftEnum<T, U>;\n"],"names":["SceneFactory","ContextFactory","SceneFactoryAdapter","InteractResultFactory","scenario","ScenarioFactory","UsecaseSelector","Robustive","KeyFactory","SwiftEnum"],"mappings":"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"}