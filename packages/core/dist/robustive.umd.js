(function(o,h){typeof exports=="object"&&typeof module!="undefined"?h(exports):typeof define=="function"&&define.amd?define(["exports"],h):(o=typeof globalThis!="undefined"?globalThis:o||self,h(o.Robustive={}))})(this,function(o){"use strict";class h{constructor(e=null){this.user=e}}class _ extends h{}const x=i=>i.constructor===_,g=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?t:Reflect.get(e,t,s)}})}},y=class{constructor(e){return new Proxy(this,{get(t,s,n){return typeof s=="string"&&!(s in t)?c=>Object.freeze(Object.assign(c||{},{scene:s,course:e})):Reflect.get(t,s,n)}})}},f=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?t:Reflect.get(e,t,s)}})}};class O{constructor(e,t,s){this.domain=e,this.usecase=t,this.id=s,this.keys={basics:new g,alternatives:new g,goals:new g},this.basics=new y("basics"),this.alternatives=new y("alternatives"),this.goals=new y("goals")}next(e,t){return this.delegate!==void 0&&this.delegate.next!==void 0?this.delegate.next(e,t,this):Promise.reject(new Error)}just(e){return Promise.resolve(e)}authorize(e,t,s){if(this.delegate!==void 0&&this.delegate.authorize!==void 0)return this.delegate.authorize(e,t,s);throw new Error(`USECASE "${s}" IS NOT AUTHORIZED FOR ACTOR "${e.constructor.name}."`)}complete(e){this.delegate!==void 0&&this.delegate.complete!==void 0&&this.delegate.complete(e)}}const A={success:"success",failure:"failure"},T=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?n=>Object.freeze(Object.assign(n,{type:t})):Reflect.get(e,t,s)}})}},z=i=>{const e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";return Array.from(crypto.getRandomValues(new Uint8Array(i))).map(t=>e[t%e.length]).join("")},w=new WeakMap;class S{constructor(e,t,s,n,c){this.id=e,this._domain=t,this._usecase=s,this._scenario=c,w.set(this,n)}get currentContext(){return w.get(this)}set currentContext(e){w.set(this,e)}set(e){this._scenario.delegate=e}progress(e){if(this._scenario.authorize&&!this._scenario.authorize(e,this._domain,this._usecase)){const t=new b(e,this._domain,this._usecase);return Promise.reject(t)}return this._scenario.next(this.currentContext,e).then(t=>(this.currentContext=t,t))}interactedBy(e){const t=new Date,s=new T,n=r=>{const a=r.slice(-1)[0];return a.course==="goals"?Promise.resolve(r):this._scenario.next(a,e).then(u=>(this.currentContext=u,r.push(u),n(r)))};if(this._scenario.authorize&&!this._scenario.authorize(e,this._domain,this._usecase)){const r=new b(e,this._domain,this._usecase);return Promise.reject(r)}const c=[this.currentContext];return n(c).then(r=>{const a=new Date,u=a.getTime()-t.getTime(),d=r.slice(-1)[0],l=s.success({id:this.id,actor:e,domain:this._domain,usecase:this._usecase,startAt:t,endAt:a,elapsedTimeMs:u,performedScenario:r,lastSceneContext:d});return this._scenario.complete&&this._scenario.complete(l),l}).catch(r=>{console.error(r);const a=new Date,u=a.getTime()-t.getTime(),d=c.slice(-1)[0],l=s.failure({id:this.id,actor:e,domain:this._domain,usecase:this._usecase,startAt:t,endAt:a,elapsedTimeMs:u,performedScenario:c,failedSceneContext:d,error:r});return this._scenario.complete&&this._scenario.complete(l),l})}}const m=class{constructor(e,t,s,n){return new Proxy(this,{get(c,r,a){return typeof r=="string"&&!(r in c)?(u,d)=>{const l=Object.assign(u||{},{scene:r,course:s}),j=d||z(8),F=new n(e,t,j),E=new S(j,e,t,l,F);return Object.freeze(Object.assign(E,{domain:e,name:t,scene:r,course:s}))}:Reflect.get(c,r,a)}})}};class v{constructor(e,t,s){this.keys={basics:new f,alternatives:new f,goals:new f},this.basics=new m(e,t,"basics",s),this.alternatives=new m(e,t,"alternatives",s),this.goals=new m(e,t,"goals",s)}}const R=class{constructor(e,t){const s=Object.keys(t);return this.keys=s.reduce((n,c)=>(n[c]=c,n),{}),new Proxy(this,{get(n,c,r){return typeof c=="string"&&s.includes(c)?new v(e,c,t[c]):Reflect.get(n,c,r)}})}},C=class{constructor(e){const t=Object.keys(e);return this.keys=t.reduce((s,n)=>(s[n]=n,s),{}),new Proxy(this,{get(s,n,c){return typeof n=="string"&&t.includes(n)?new R(n,e[n]):Reflect.get(s,n,c)}})}};class b extends Error{constructor(e,t,s){super(`The actor "${e.constructor.name}" is not authorized to interact on usecase "${String(s)}" of domain "${String(t)}".`)}}const I=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?t:Reflect.get(e,t,s)}})}},P=class{constructor(e){return this.keys=new I,new Proxy(this,{get(t,s,n){return typeof s=="string"&&!(s in t)?c=>Object.freeze(e!==void 0?Object.assign(new e,Object.assign(c||{},{case:s})):Object.assign(c||{},{case:s})):Reflect.get(t,s,n)}})}};o.AbstractActor=h,o.ActorNotAuthorizedToInteractIn=b,o.CourseSelector=v,o.InteractResultType=A,o.Nobody=_,o.Robustive=C,o.Scenario=O,o.SwiftEnum=P,o.UsecaseImple=S,o.UsecaseSelector=R,o.isNobody=x,Object.defineProperties(o,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
//# sourceMappingURL=robustive.umd.js.map
