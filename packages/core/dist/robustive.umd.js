(function(o,d){typeof exports=="object"&&typeof module!="undefined"?d(exports):typeof define=="function"&&define.amd?define(["exports"],d):(o=typeof globalThis!="undefined"?globalThis:o||self,d(o.Robustive={}))})(this,function(o){"use strict";class d{constructor(e=null){this.user=e}}const g=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?t:Reflect.get(e,t,s)}})}},f=class{constructor(e){return new Proxy(this,{get(t,s,n){return typeof s=="string"&&!(s in t)?i=>Object.freeze(Object.assign(i||{},{scene:s,course:e})):Reflect.get(t,s,n)}})}},y=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?t:Reflect.get(e,t,s)}})}};class x{constructor(e,t,s){this.domain=e,this.usecase=t,this.id=s,this.keys={basics:new g,alternatives:new g,goals:new g},this.basics=new f("basics"),this.alternatives=new f("alternatives"),this.goals=new f("goals")}next(e,t){return this.delegate!==void 0&&this.delegate.next!==void 0?this.delegate.next(e,t,this):Promise.reject(new Error)}just(e){return Promise.resolve(e)}authorize(e,t,s){if(this.delegate!==void 0&&this.delegate.authorize!==void 0)return this.delegate.authorize(e,t,s);throw new Error(`USECASE "${s}" IS NOT AUTHORIZED FOR ACTOR "${e.constructor.name}."`)}complete(e){this.delegate!==void 0&&this.delegate.complete!==void 0&&this.delegate.complete(e)}}const O={success:"success",failure:"failure"},A=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?n=>Object.freeze(Object.assign(n,{type:t})):Reflect.get(e,t,s)}})}},T=r=>{const e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";return Array.from(crypto.getRandomValues(new Uint8Array(r))).map(t=>e[t%e.length]).join("")},w=new WeakMap;class _{constructor(e,t,s,n,i){this.id=e,this._domain=t,this._usecase=s,this._scenario=i,w.set(this,n)}get currentContext(){return w.get(this)}set currentContext(e){w.set(this,e)}set(e){this._scenario.delegate=e}progress(e){if(this._scenario.authorize&&!this._scenario.authorize(e,this._domain,this._usecase)){const t=new b(e,this._domain,this._usecase);return Promise.reject(t)}return this._scenario.next(this.currentContext,e).then(t=>(this.currentContext=t,t))}interactedBy(e){const t=new Date,s=new A,n=c=>{const a=c.slice(-1)[0];return a.course==="goals"?Promise.resolve(c):this._scenario.next(a,e).then(l=>(this.currentContext=l,c.push(l),n(c)))};if(this._scenario.authorize&&!this._scenario.authorize(e,this._domain,this._usecase)){const c=new b(e,this._domain,this._usecase);return Promise.reject(c)}const i=[this.currentContext];return n(i).then(c=>{const a=new Date,l=a.getTime()-t.getTime(),h=c.slice(-1)[0],u=s.success({id:this.id,actor:e,domain:this._domain,usecase:this._usecase,startAt:t,endAt:a,elapsedTimeMs:l,performedScenario:c,lastSceneContext:h});return this._scenario.complete&&this._scenario.complete(u),u}).catch(c=>{console.error(c);const a=new Date,l=a.getTime()-t.getTime(),h=i.slice(-1)[0],u=s.failure({id:this.id,actor:e,domain:this._domain,usecase:this._usecase,startAt:t,endAt:a,elapsedTimeMs:l,performedScenario:i,failedSceneContext:h,error:c});return this._scenario.complete&&this._scenario.complete(u),u})}}const m=class{constructor(e,t,s,n){return new Proxy(this,{get(i,c,a){return typeof c=="string"&&!(c in i)?(...l)=>{let h,u;const S=l[0],j=l[1];typeof S=="string"?(u=S,h=void 0):(h=S,u=typeof j=="string"?j:T(8));const P=Object.assign(h||{},{scene:c,course:s}),F=new n(e,t,u),E=new _(u,e,t,P,F);return Object.freeze(Object.assign(E,{domain:e,name:t,scene:c,course:s}))}:Reflect.get(i,c,a)}})}};class v{constructor(e,t,s){this.keys={basics:new y,alternatives:new y,goals:new y},this.basics=new m(e,t,"basics",s),this.alternatives=new m(e,t,"alternatives",s),this.goals=new m(e,t,"goals",s)}}const R=class{constructor(e,t){const s=Object.keys(t);return this.keys=s.reduce((n,i)=>(n[i]=i,n),{}),new Proxy(this,{get(n,i,c){return typeof i=="string"&&s.includes(i)?new v(e,i,t[i]):Reflect.get(n,i,c)}})}},z=class{constructor(e){const t=Object.keys(e);return this.keys=t.reduce((s,n)=>(s[n]=n,s),{}),new Proxy(this,{get(s,n,i){return typeof n=="string"&&t.includes(n)?new R(n,e[n]):Reflect.get(s,n,i)}})}};class b extends Error{constructor(e,t,s){super(`The actor "${e.constructor.name}" is not authorized to interact on usecase "${String(s)}" of domain "${String(t)}".`)}}const C=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?t:Reflect.get(e,t,s)}})}},I=class{constructor(e){return this.keys=new C,new Proxy(this,{get(t,s,n){return typeof s=="string"&&!(s in t)?i=>Object.freeze(e!==void 0?Object.assign(new e,Object.assign(i||{},{case:s})):Object.assign(i||{},{case:s})):Reflect.get(t,s,n)}})}};o.AbstractActor=d,o.ActorNotAuthorizedToInteractIn=b,o.CourseSelector=v,o.InteractResultType=O,o.Robustive=z,o.Scenario=x,o.SwiftEnum=I,o.UsecaseImple=_,o.UsecaseSelector=R,Object.defineProperties(o,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
//# sourceMappingURL=robustive.umd.js.map
