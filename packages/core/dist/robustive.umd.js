(function(o,h){typeof exports=="object"&&typeof module!="undefined"?h(exports):typeof define=="function"&&define.amd?define(["exports"],h):(o=typeof globalThis!="undefined"?globalThis:o||self,h(o.Robustive={}))})(this,function(o){"use strict";class h{constructor(e=null){this.user=e}}class b extends h{}const j=r=>r.constructor===b,g=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?t:Reflect.get(e,t,s)}})}},f=class{constructor(e){return new Proxy(this,{get(t,s,n){return typeof s=="string"&&!(s in t)?c=>Object.freeze(Object.assign(c||{},{scene:s,course:e})):Reflect.get(t,s,n)}})}},y=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?t:Reflect.get(e,t,s)}})}};class O{constructor(e,t,s,n=!1){this.domain=e,this.usecase=t,this.id=s,this.isSubstitute=n,this.keys={basics:new g,alternatives:new g,goals:new g},this.basics=new f("basics"),this.alternatives=new f("alternatives"),this.goals=new f("goals")}next(e,t){return this.delegate!==void 0&&this.delegate.next!==void 0?this.delegate.next(e,t,this):Promise.reject(new Error)}just(e){return Promise.resolve(e)}authorize(e,t,s){if(this.delegate!==void 0&&this.delegate.authorize!==void 0)return this.delegate.authorize(e,t,s);throw new Error(`USECASE "${s}" IS NOT AUTHORIZED FOR ACTOR "${e.constructor.name}."`)}complete(e){this.delegate!==void 0&&this.delegate.complete!==void 0&&this.delegate.complete(e)}}const A={success:"success",failure:"failure"},x=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?n=>Object.freeze(Object.assign(n,{type:t})):Reflect.get(e,t,s)}})}},T=r=>{const e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";return Array.from(crypto.getRandomValues(new Uint8Array(r))).map(t=>e[t%e.length]).join("")};class _{constructor(e,t,s,n,c){this.id=e,this._domain=t,this._usecase=s,this._currentContext=n,this._scenario=c}set(e){this._scenario.delegate=e}progress(e){if(this._scenario.authorize&&!this._scenario.authorize(e,this._domain,this._usecase)){const t=new w(e,this._domain,this._usecase);return Promise.reject(t)}return this._scenario.next(this._currentContext,e).then(t=>(this._currentContext=t,t))}interactedBy(e){const t=new Date,s=new x,n=i=>{const a=i.slice(-1)[0];return a.course==="goals"?Promise.resolve(i):this._scenario.next(a,e).then(u=>(this._currentContext=u,i.push(u),n(i)))};if(this._scenario.authorize&&!this._scenario.authorize(e,this._domain,this._usecase)){const i=new w(e,this._domain,this._usecase);return Promise.reject(i)}const c=[this._currentContext];return n(c).then(i=>{const a=new Date,u=a.getTime()-t.getTime(),d=i.slice(-1)[0],l=s.success({id:this.id,actor:e,domain:this._domain,usecase:this._usecase,startAt:t,endAt:a,elapsedTimeMs:u,performedScenario:i,lastSceneContext:d});return this._scenario.complete&&this._scenario.complete(l),l}).catch(i=>{console.error(i);const a=new Date,u=a.getTime()-t.getTime(),d=c.slice(-1)[0],l=s.failure({id:this.id,actor:e,domain:this._domain,usecase:this._usecase,startAt:t,endAt:a,elapsedTimeMs:u,performedScenario:c,failedSceneContext:d,error:i});return this._scenario.complete&&this._scenario.complete(l),l})}}const m=class{constructor(e,t,s,n){return new Proxy(this,{get(c,i,a){return typeof i=="string"&&!(i in c)?(u,d,l=!1)=>{const C=Object.assign(u||{},{scene:i,course:s}),R=d||T(8),F=new n(e,t,R,l),E=new _(R,e,t,C,F);return Object.freeze(Object.assign(E,{domain:e,name:t,scene:i,course:s}))}:Reflect.get(c,i,a)}})}};class S{constructor(e,t,s){this.keys={basics:new y,alternatives:new y,goals:new y},this.basics=new m(e,t,"basics",s),this.alternatives=new m(e,t,"alternatives",s),this.goals=new m(e,t,"goals",s)}}const v=class{constructor(e,t){const s=Object.keys(t);return this.keys=s.reduce((n,c)=>(n[c]=c,n),{}),new Proxy(this,{get(n,c,i){return typeof c=="string"&&s.includes(c)?new S(e,c,t[c]):Reflect.get(n,c,i)}})}},z=class{constructor(e){const t=Object.keys(e);return this.keys=t.reduce((s,n)=>(s[n]=n,s),{}),new Proxy(this,{get(s,n,c){return typeof n=="string"&&t.includes(n)?new v(n,e[n]):Reflect.get(s,n,c)}})}};class w extends Error{constructor(e,t,s){super(`The actor "${e.constructor.name}" is not authorized to interact on usecase "${String(s)}" of domain "${String(t)}".`)}}const I=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?t:Reflect.get(e,t,s)}})}},P=class{constructor(e){return this.keys=new I,new Proxy(this,{get(t,s,n){return typeof s=="string"&&!(s in t)?c=>Object.freeze(e!==void 0?Object.assign(new e,Object.assign(c||{},{case:s})):Object.assign(c||{},{case:s})):Reflect.get(t,s,n)}})}};o.AbstractActor=h,o.ActorNotAuthorizedToInteractIn=w,o.CourseSelector=S,o.InteractResultType=A,o.Nobody=b,o.Robustive=z,o.Scenario=O,o.SwiftEnum=P,o.UsecaseImple=_,o.UsecaseSelector=v,o.isNobody=j,Object.defineProperties(o,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
