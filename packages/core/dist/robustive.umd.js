(function(o,h){typeof exports=="object"&&typeof module!="undefined"?h(exports):typeof define=="function"&&define.amd?define(["exports"],h):(o=typeof globalThis!="undefined"?globalThis:o||self,h(o.Robustive={}))})(this,function(o){"use strict";class h{constructor(e=null){this.user=e}}const g=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?t:Reflect.get(e,t,s)}})}},f=class{constructor(e){return new Proxy(this,{get(t,s,n){return typeof s=="string"&&!(s in t)?c=>Object.freeze(Object.assign(c||{},{scene:s,course:e})):Reflect.get(t,s,n)}})}},y=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?t:Reflect.get(e,t,s)}})}};class j{constructor(e,t,s){this.domain=e,this.usecase=t,this.id=s,this.keys={basics:new g,alternatives:new g,goals:new g},this.basics=new f("basics"),this.alternatives=new f("alternatives"),this.goals=new f("goals")}next(e,t){return this.delegate!==void 0&&this.delegate.next!==void 0?this.delegate.next(e,t,this):Promise.reject(new Error)}just(e){return Promise.resolve(e)}authorize(e,t,s){if(this.delegate!==void 0&&this.delegate.authorize!==void 0)return this.delegate.authorize(e,t,s);throw new Error(`USECASE "${s}" IS NOT AUTHORIZED FOR ACTOR "${e.constructor.name}."`)}complete(e){this.delegate!==void 0&&this.delegate.complete!==void 0&&this.delegate.complete(e)}}const x={success:"success",failure:"failure"},O=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?n=>Object.freeze(Object.assign(n,{type:t})):Reflect.get(e,t,s)}})}},A=i=>{const e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";return Array.from(crypto.getRandomValues(new Uint8Array(i))).map(t=>e[t%e.length]).join("")},w=new WeakMap;class _{constructor(e,t,s,n,c){this.id=e,this._domain=t,this._usecase=s,this._scenario=c,w.set(this,n)}get currentContext(){return w.get(this)}set currentContext(e){w.set(this,e)}set(e){this._scenario.delegate=e}progress(e){if(this._scenario.authorize&&!this._scenario.authorize(e,this._domain,this._usecase)){const t=new b(e,this._domain,this._usecase);return Promise.reject(t)}return this._scenario.next(this.currentContext,e).then(t=>(this.currentContext=t,t))}interactedBy(e){const t=new Date,s=new O,n=r=>{const a=r.slice(-1)[0];return a.course==="goals"?Promise.resolve(r):this._scenario.next(a,e).then(u=>(this.currentContext=u,r.push(u),n(r)))};if(this._scenario.authorize&&!this._scenario.authorize(e,this._domain,this._usecase)){const r=new b(e,this._domain,this._usecase);return Promise.reject(r)}const c=[this.currentContext];return n(c).then(r=>{const a=new Date,u=a.getTime()-t.getTime(),d=r.slice(-1)[0],l=s.success({id:this.id,actor:e,domain:this._domain,usecase:this._usecase,startAt:t,endAt:a,elapsedTimeMs:u,performedScenario:r,lastSceneContext:d});return this._scenario.complete&&this._scenario.complete(l),l}).catch(r=>{console.error(r);const a=new Date,u=a.getTime()-t.getTime(),d=c.slice(-1)[0],l=s.failure({id:this.id,actor:e,domain:this._domain,usecase:this._usecase,startAt:t,endAt:a,elapsedTimeMs:u,performedScenario:c,failedSceneContext:d,error:r});return this._scenario.complete&&this._scenario.complete(l),l})}}const m=class{constructor(e,t,s,n){return new Proxy(this,{get(c,r,a){return typeof r=="string"&&!(r in c)?(u,d)=>{const l=Object.assign(u||{},{scene:r,course:s}),R=d||A(8),I=new n(e,t,R),P=new _(R,e,t,l,I);return Object.freeze(Object.assign(P,{domain:e,name:t,scene:r,course:s}))}:Reflect.get(c,r,a)}})}};class S{constructor(e,t,s){this.keys={basics:new y,alternatives:new y,goals:new y},this.basics=new m(e,t,"basics",s),this.alternatives=new m(e,t,"alternatives",s),this.goals=new m(e,t,"goals",s)}}const v=class{constructor(e,t){const s=Object.keys(t);return this.keys=s.reduce((n,c)=>(n[c]=c,n),{}),new Proxy(this,{get(n,c,r){return typeof c=="string"&&s.includes(c)?new S(e,c,t[c]):Reflect.get(n,c,r)}})}},T=class{constructor(e){const t=Object.keys(e);return this.keys=t.reduce((s,n)=>(s[n]=n,s),{}),new Proxy(this,{get(s,n,c){return typeof n=="string"&&t.includes(n)?new v(n,e[n]):Reflect.get(s,n,c)}})}};class b extends Error{constructor(e,t,s){super(`The actor "${e.constructor.name}" is not authorized to interact on usecase "${String(s)}" of domain "${String(t)}".`)}}const z=class{constructor(){return new Proxy(this,{get(e,t,s){return typeof t=="string"&&!(t in e)?t:Reflect.get(e,t,s)}})}},C=class{constructor(e){return this.keys=new z,new Proxy(this,{get(t,s,n){return typeof s=="string"&&!(s in t)?c=>Object.freeze(e!==void 0?Object.assign(new e,Object.assign(c||{},{case:s})):Object.assign(c||{},{case:s})):Reflect.get(t,s,n)}})}};o.AbstractActor=h,o.ActorNotAuthorizedToInteractIn=b,o.CourseSelector=S,o.InteractResultType=x,o.Robustive=T,o.Scenario=j,o.SwiftEnum=C,o.UsecaseImple=_,o.UsecaseSelector=v,Object.defineProperties(o,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
//# sourceMappingURL=robustive.umd.js.map
