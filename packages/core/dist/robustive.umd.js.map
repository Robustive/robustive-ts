{"version":3,"file":"robustive.umd.js","sources":["../src/actor.ts","../src/usecase.ts","../src/enum.ts"],"sourcesContent":["import { DomainRequirements } from \"./usecase\";\n\nexport interface IActor<User> {\n    user: User | null;\n    isAuthorizedTo?: <R extends DomainRequirements>(domain: keyof R, usecase: keyof R[keyof R]) => boolean\n}\n\nexport abstract class AbstractActor<User> implements IActor<User> {\n    user: User | null;\n    constructor(user: User | null = null) {\n        this.user = user;\n    }\n\n    abstract isAuthorizedTo?: <R extends DomainRequirements>(domain: keyof R, usecase: keyof R[keyof R]) => boolean\n}\n\nexport class Nobody extends AbstractActor<null> {\n    isAuthorizedTo?: (<R extends DomainRequirements>(domain: keyof R, usecase: keyof R[keyof R]) => boolean) | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isNobody = (actor: any): actor is Nobody => actor.constructor === Nobody;\n","import { IActor } from \"./actor\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type NOCARE = any;\n\ntype PreFlatten<Z> = {\n    [C in keyof Z as C extends string \n        ? Z[C] extends Empty // for empty alternatives\n            ? never\n            : `${C}.${keyof Z[C] & string}`\n        : C\n    ] : Z[C];\n};\n\ntype Flatten<Z> = {\n    [CK in keyof PreFlatten<Z>] : CK extends `${infer C extends keyof Z & string}.${string}`\n        ? CK extends `${string}.${infer K extends keyof Z[C] & string}`\n            ? Z[C][K] \n            : never\n        : never;\n};\n\nconst courses = [\"basics\", \"alternatives\", \"goals\"] as const;\nexport type Courses = typeof courses[number];\ntype Basics = Extract<Courses, \"basics\">;\ntype Alternatives = Extract<Courses, \"alternatives\">;\ntype Goals = Extract<Courses, \"goals\">;\n\ntype ContextualValues = Record<string, object>;\nexport type Empty = Record<string, never>;\n\nexport type Scenes = {\n    basics: ContextualValues;\n    alternatives: ContextualValues;\n    goals: ContextualValues;\n};\n\n// Convert Scenes into Discriminated Union like { scene: \"...\", ... }\nexport type Context<Z extends Scenes> = {\n    readonly [K in keyof Flatten<Z>]: K extends `${ infer C }.${ infer S }` \n        ? Flatten<Z>[K] extends Empty\n            ? { scene: S; course: C; }\n            : { scene: S; course: C; } & Flatten<Z>[K]\n        : never \n}[keyof Flatten<Z>];\n\nexport type ContextOf<Z extends Scenes, C extends Courses> = {\n    readonly [S in keyof Z[C]]:\n        Z[C][S] extends Empty\n            ? { scene: S; course: C; }\n            : { scene: S; course: C; } & Z[C][S]\n}[keyof Z[C]];\n\ntype SceneFactory<Z extends Scenes, C extends Courses> = Z[C] extends Empty\n    ? Empty // for empty alternatives\n    : { \n        [K in keyof Z[C]]: K\n    };\n\nconst SceneFactory = class SceneFactory {\n    constructor() {\n        return new Proxy(this, {\n            get(target, prop, receiver) { // prop = scene\n                return ((typeof prop === \"string\") && !(prop in target))\n                    ? prop\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <Z extends Scenes, C extends Courses>() => SceneFactory<Z, C>;\n    \ntype ContextFactory<Z extends Scenes, C extends Courses> = Z[C] extends Empty\n    ? Empty // for empty alternatives\n    : { \n        [K in keyof Z[C]]: Z[C][K] extends Empty\n            ? () => Context<Z>\n            : (withValues: Z[C][K]) => Context<Z>\n    };\n\n/**\n * The context factory held by the scenario instance passed as an argument \n * to the next function of ScenarioDelegate, which is called during the execution\n * of a usecase scenario. This is used to create the context for the next scene.\n */\nconst ContextFactory = class ContextFactory<C extends Courses> {\n    constructor(course: C) {\n        return new Proxy(this, {\n            get(target, prop, receiver) { // prop = scene\n                return ((typeof prop === \"string\") && !(prop in target))\n                    ? (withValues?: ContextualValues) => {\n                        return Object.freeze(Object.assign(withValues || {}, { \"scene\" : prop, course }));\n                    }\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <Z extends Scenes, C extends Courses>(course: C) => ContextFactory<Z, C>;\n\ntype UsecaseScenarios<D extends string> = { [U in string] : new (domain: D, usecase: U, id: string) => Scenario<NOCARE> };\nexport type DomainRequirements = { [D in string] :  UsecaseScenarios<D> };\n\ntype DomainKeys<R extends DomainRequirements> = {\n    [D in keyof R]: D\n};\n\ntype UsecaseKeys<R extends DomainRequirements, D extends keyof R> = {\n    [U in keyof R[D]]: U\n};\n\nexport type InferScenes<R extends DomainRequirements, D extends keyof R, U extends keyof R[D]> = {\n  [U in keyof R[D]]: R[D][U] extends {\n    new (domain: string, usecase: string, id: string): Scenario<infer Z extends Scenes>\n  }\n    ? Z\n    : never\n}[U];\n\ntype SceneFactoryAdapter<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], C extends Courses> = InferScenes<R, D, U>[C] extends Empty\n    ? Empty // for Empty alternative\n    : SceneFactory<InferScenes<R, D, U>, C>;\n\nconst SceneFactoryAdapter = class SceneFactoryAdapter {\n    constructor() {\n        return new Proxy(this, {\n            get(target, prop, receiver) { // prop = scene\n                return ((typeof prop === \"string\") && !(prop in target))\n                    ? prop\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <R extends DomainRequirements, D extends keyof R, U extends keyof R[D], C extends Courses>() => SceneFactoryAdapter<R, D, U, C>;\n\nexport type StringKeyof<T> = Extract<keyof T, string>;\n\n// export type InferScenesInScenario<T> = T extends Scenario<infer Z extends Scenes> ? Z : never;\n\nexport interface IScenarioDelegate<Z extends Scenes> {\n    next?<A extends IActor<NOCARE>, S extends Scenario<Z>>(to: Context<Z>, actor: A, scenario: S): Promise<Context<Z>>;\n    authorize?<A extends IActor<NOCARE>, R extends DomainRequirements, D extends StringKeyof<R>, U extends StringKeyof<R[D]>>(actor: A, domain: D, usecase: U): boolean;\n    complete?<A extends IActor<NOCARE>, R extends DomainRequirements, D extends keyof R, U extends keyof R[D]>(withResult: InteractResult<R, D, U, A, Z>): void;\n}\n\n\n// for declaring like \"SomeScenario<SomeScenes>\", cannot use generics parameters \"D extends UsecaseDefinitions, U extends keyof D\"\nexport class Scenario<Z extends Scenes> {\n    readonly domain: string;\n    readonly usecase: string;\n    readonly id: string;\n    delegate?: IScenarioDelegate<Z>;\n    readonly keys: {\n        readonly basics : SceneFactory<Z, Basics>;\n        readonly alternatives : SceneFactory<Z, Alternatives>;\n        readonly goals : SceneFactory<Z, Goals>;\n    };\n    readonly basics: ContextFactory<Z, Basics>;\n    readonly alternatives: ContextFactory<Z, Alternatives>;\n    readonly goals: ContextFactory<Z, Goals>;\n\n    constructor(domain: string, usecase: string, id: string) {\n        this.domain = domain;\n        this.usecase = usecase;\n        this.id = id;\n        this.keys = {\n            basics: new SceneFactory<Z, Basics>()\n            , alternatives: new SceneFactory<Z, Alternatives>()\n            , goals: new SceneFactory<Z, Goals>()\n        };\n        this.basics = new ContextFactory<Z, Basics>(\"basics\");\n        this.alternatives = new ContextFactory<Z, Alternatives>(\"alternatives\");\n        this.goals = new ContextFactory<Z, Goals>(\"goals\");\n    }\n\n    next<A extends IActor<NOCARE>>(to: Context<Z>, actor: A): Promise<Context<Z>> {\n        if (this.delegate !== undefined && this.delegate.next !== undefined) {\n            return this.delegate.next(to, actor, this);\n        }\n        return Promise.reject(new Error());\n    }\n    \n    just(next: Context<Z>) : Promise<Context<Z>> {\n        return Promise.resolve(next);\n    }\n\n    authorize<A extends IActor<NOCARE>, R extends DomainRequirements, D extends StringKeyof<R>, U extends StringKeyof<R[D]>>(actor: A, domain: D, usecase: U): boolean {\n        if (this.delegate !== undefined && this.delegate.authorize !== undefined) {\n            return this.delegate.authorize(actor, domain, usecase);\n        }\n        throw new Error(`USECASE \"${usecase}\" IS NOT AUTHORIZED FOR ACTOR \"${actor.constructor.name}.\"`);\n    }\n\n    complete<A extends IActor<NOCARE>, R extends DomainRequirements, D extends keyof R, U extends keyof R[D]>(withResult: InteractResult<R, D, U, A, Z>): void {\n        if (this.delegate !== undefined && this.delegate.complete !== undefined) {\n            this.delegate.complete(withResult);\n        }\n    }\n}\n\nexport const InteractResultType = {\n    success: \"success\"\n    , failure: \"failure\"\n} as const;\n\ntype InteractResultContext<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends Scenes> = {\n    [InteractResultType.success] : {\n        id: string;\n        actor : A;\n        domain : D;\n        usecase : U;\n        startAt : Date;\n        endAt : Date;\n        elapsedTimeMs : number;\n        performedScenario : Context<Z>[];\n        lastSceneContext : ContextOf<Z, \"goals\">;\n    };\n    [InteractResultType.failure] : {\n        id: string;\n        actor : A;\n        domain : D;\n        usecase : U;\n        startAt : Date;\n        endAt : Date;\n        elapsedTimeMs : number;\n        performedScenario : Context<Z>[];\n        failedSceneContext : Context<Z>;\n        error: Error;\n    };\n};\n\ntype InteractResultCase<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends Scenes, K extends keyof InteractResultContext<R, D, U, A, Z>> = Record<\"type\", K> & InteractResultContext<R, D, U, A, Z>[K];\n\nexport type InteractResult<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends Scenes> = { \n    [K in keyof InteractResultContext<R, D, U, A, Z>] : InteractResultCase<R, D, U, A, Z, K>;\n}[keyof InteractResultContext<R, D, U, A, Z>];\n\n\ntype InteractResultSelector<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends Scenes> = { \n    [K in keyof InteractResultContext<R, D, U, A, Z>] : (withValues: InteractResultContext<R, D, U, A, Z>[K]) => InteractResultCase<R, D, U, A, Z, K>;\n};\n\nconst InteractResultFactory = class InteractResultFactory {\n    constructor() {\n        return new Proxy(this, {\n            get(target, prop, receiver) {\n                return ((typeof prop === \"string\") && !(prop in target))\n                    ? (withValues: object) => {\n                        return Object.freeze(Object.assign(withValues, { \"type\" : prop }));\n                    }\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends InferScenes<R, D, U>>() => InteractResultSelector<R, D, U, A, Z>;\n\nconst generateId = (length: number) => { \n    const S = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; \n    return Array.from(crypto.getRandomValues(new Uint8Array(length))).map((n)=>S[n%S.length]).join(\"\");\n};\n\n// Manage currentContext with WeakMap because UsecaseImple instances are frozen.\nconst currentContextStore = new WeakMap<object, NOCARE>();\n\nexport class UsecaseImple<R extends DomainRequirements, D extends keyof R, U extends keyof R[D]> {\n    readonly id: string;\n    private readonly _domain: D;\n    private readonly _usecase: U;\n    private readonly _scenario: Scenario<InferScenes<R, D, U>>;\n\n    constructor(id: string, domain: D, usecase: U, initialContext: Context<InferScenes<R, D, U>>, scenario: Scenario<InferScenes<R, D, U>>) {\n        this.id = id;\n        this._domain = domain;\n        this._usecase = usecase;\n        this._scenario = scenario;\n        currentContextStore.set(this, initialContext);\n    }\n\n    get currentContext(): Context<InferScenes<R, D, U>> {\n        return currentContextStore.get(this);\n    }\n\n    set currentContext(context: Context<InferScenes<R, D, U>>) {\n        currentContextStore.set(this, context);\n    }\n\n    set(delegate: IScenarioDelegate<InferScenes<R, D, U>>): void {\n        this._scenario.delegate = delegate;\n    }\n\n    /**\n     * Step through the usecase scenario from the current scene to the next scene.\n     * @param actor \n     * @returns \n     */\n    progress<User, A extends IActor<User>>(actor: A): Promise<Context<InferScenes<R, D, U>>> {\n        if (this._scenario.authorize && !this._scenario.authorize(actor, this._domain as Extract<D, string>, this._usecase as Extract<U, string>)) {\n            const err = new ActorNotAuthorizedToInteractIn(actor, this._domain, this._usecase);\n            return Promise.reject(err);\n        }\n        return this._scenario.next(this.currentContext, actor)\n            .then(nextScene => {\n                this.currentContext = nextScene;\n                return nextScene;\n            });\n    }\n\n    /**\n     * Execute the use case to completion according to the defined scenario.\n     * @param actor \n     * @returns \n     */\n    interactedBy<User, A extends IActor<User>>(actor: A): Promise<InteractResult<R, D, U, A, InferScenes<R, D, U>>> {\n        const startAt = new Date();\n        const InteractResult = new InteractResultFactory<R, D, U, A, InferScenes<R, D, U>>();\n\n        const recursive = (scenario: Context<InferScenes<R, D, U>>[]): Promise<Context<InferScenes<R, D, U>>[]> => {\n            const lastScene = scenario.slice(-1)[0];\n            if (lastScene.course === \"goals\") { // exit criteria\n                return Promise.resolve(scenario);\n            }\n\n            return this._scenario.next(lastScene, actor)\n                .then((nextScene) => {\n                    this.currentContext = nextScene;\n                    scenario.push(nextScene);\n                    return recursive(scenario);\n                });\n        };\n\n        if (this._scenario.authorize && !this._scenario.authorize(actor, this._domain as Extract<D, string>, this._usecase as Extract<U, string>)) {\n            const err = new ActorNotAuthorizedToInteractIn(actor, this._domain, this._usecase);\n            return Promise.reject(err);\n        }\n        const scenario: Context<InferScenes<R, D, U>>[] = [this.currentContext];\n        return recursive(scenario)\n            .then((performedScenario) => {\n                const endAt = new Date();\n                const elapsedTimeMs = (endAt.getTime() - startAt.getTime());\n                const lastSceneContext = performedScenario.slice(-1)[0] as ContextOf<InferScenes<R, D, U>, \"goals\">;\n                const result = InteractResult.success({\n                    id: this.id\n                    , actor\n                    , domain: this._domain\n                    , usecase : this._usecase\n                    , startAt\n                    , endAt\n                    , elapsedTimeMs\n                    , performedScenario\n                    , lastSceneContext\n                });\n                if (this._scenario.complete) { this._scenario.complete(result); }\n                return result;\n            })\n            .catch((err) => {\n                console.error(err);\n                const endAt = new Date();\n                const elapsedTimeMs = (endAt.getTime() - startAt.getTime());\n                const lastSceneContext = scenario.slice(-1)[0];\n                const result =  InteractResult.failure({\n                    id: this.id\n                    , actor\n                    , domain: this._domain\n                    , usecase : this._usecase\n                    , startAt\n                    , endAt\n                    , elapsedTimeMs\n                    , performedScenario : scenario\n                    , failedSceneContext : lastSceneContext\n                    , error : err\n                });\n                if (this._scenario.complete) { this._scenario.complete(result); }\n                return result;\n            });\n    }\n}\n\ntype UsecaseContext<R extends DomainRequirements, D extends keyof R, U extends keyof R[D]>  = {\n    \"domain\": D;\n    \"name\" : U; // The property name is name instead of usecase because it is assumed that it will be used as usecase.name when used.\n    \"course\": Courses;\n    \"scene\": string;\n}\n\nexport type Usecase<R extends DomainRequirements, D extends keyof R, U extends keyof R[D]> = UsecaseContext<R, D, U> & UsecaseImple<R, D, U>;\n\n// for making usecase as Discriminated Union, must use \"keyof D\" for type of name, not use \"string\".\ntype ScenarioFactory<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], C extends Courses> = InferScenes<R, D, U>[C] extends Empty\n    ? Empty // for Empty alternative\n    : {\n        [K in keyof InferScenes<R, D, U>[C]]: InferScenes<R, D, U>[C][K] extends Empty\n            ? (id?: string) => Usecase<R, D, U>\n            : (withValues: InferScenes<R, D, U>[C][K], id?: string) => Usecase<R, D, U>\n    };\n\n/**\n * The scenario factory invoked via the UsecaseSelector and CourseSelector\n * held by the Robustive instance. This is used to create an instance of the usecase\n * to be executed.\n */\nconst ScenarioFactory = class ScenarioFactory<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], C extends Courses> {\n    constructor(domain: D, usecase: U, course: C, scenario: new (domain: D, usecase: U, id: string) => Scenario<InferScenes<R, D, U>>) {\n        return new Proxy(this, {\n            get(target, prop, receiver) {\n                return ((typeof prop === \"string\") && !(prop in target))\n                    ? (withValues?: ContextualValues, id?: string) => {\n                        const context = Object.assign(withValues || {}, { \"scene\" : prop, course }) as unknown as Context<InferScenes<R, D, U>>;\n                        const _id = id || generateId(8);\n                        const s = new scenario(domain, usecase, _id);\n                        const usecaseImple = new UsecaseImple<R, D, U>(_id, domain, usecase, context, s);\n                        return Object.freeze(Object.assign(usecaseImple, { \"domain\": domain, \"name\" : usecase, \"scene\": prop, course }));\n                    }\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <R extends DomainRequirements, D extends keyof R, U extends keyof R[D], C extends Courses>(domain: D, usecase: U, course: C, scenario: new (domain: D, usecase: U, id: string) => Scenario<InferScenes<R, D, U>>) => ScenarioFactory<R, D, U, C>;\n\nexport class CourseSelector<R extends DomainRequirements, D extends keyof R, U extends keyof R[D]> {\n    readonly keys: {\n        readonly basics : SceneFactoryAdapter<R, D, U, Basics>;\n        readonly alternatives : SceneFactoryAdapter<R, D, U, Alternatives>;\n        readonly goals : SceneFactoryAdapter<R, D, U, Goals>;\n    };\n    readonly basics: ScenarioFactory<R, D, U, Basics>;\n    readonly alternatives: ScenarioFactory<R, D, U, Alternatives>;\n    readonly goals: ScenarioFactory<R, D, U, Goals>;\n\n    constructor(domain: D, usecase: U, scenario: new (domain: D, usecase: U, id: string) => Scenario<InferScenes<R, D, U>>) {\n        this.keys = {\n            basics: new SceneFactoryAdapter<R, D, U, Basics>()\n            , alternatives: new SceneFactoryAdapter<R, D, U, Alternatives>()\n            , goals: new SceneFactoryAdapter<R, D, U, Goals>()\n        };\n        this.basics = new ScenarioFactory<R, D, U, Basics>(domain, usecase, \"basics\", scenario);\n        this.alternatives = new ScenarioFactory<R, D, U, Alternatives>(domain, usecase, \"alternatives\", scenario);\n        this.goals = new ScenarioFactory<R, D, U, Goals>(domain, usecase, \"goals\", scenario);\n    }\n}\n\nexport type UsecaseSelector<R extends DomainRequirements, D extends StringKeyof<R>> = Record<\"keys\", UsecaseKeys<R, D>> & { \n    [U in keyof R[D]]: CourseSelector<R, D, U>\n};\n\nexport const UsecaseSelector = class UsecaseSelector<R extends DomainRequirements, D extends StringKeyof<R>> {\n    readonly keys: UsecaseKeys<R, D>;\n    constructor(domain: D, scenarioConstructors: UsecaseScenarios<D>) {\n        const usecaseKeys = Object.keys(scenarioConstructors);\n        this.keys = usecaseKeys.reduce<Record<string, string>>((keys, usecase) => {\n            keys[usecase] = usecase;\n            return keys;\n        }, {}) as UsecaseKeys<R, D>;\n        return new Proxy(this, {\n            get(target, prop, receiver) { // prop = usecase\n                return ((typeof prop === \"string\") && usecaseKeys.includes(prop))\n                    ? new CourseSelector<R, D, StringKeyof<UsecaseScenarios<D>>>(domain, prop, scenarioConstructors[prop])\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <R extends DomainRequirements, D extends StringKeyof<R>>(domain: D, scenarioConstructors: UsecaseScenarios<D>) => UsecaseSelector<R, D>;\n\nexport type Robustive<R extends DomainRequirements> = Record<\"keys\", DomainKeys<R>> & {\n    [D in StringKeyof<R>] : UsecaseSelector<R, D>;\n};\n\nexport const Robustive = class Robustive<R extends DomainRequirements> {\n    readonly keys: DomainKeys<R>;\n    constructor(requirements: R) {\n        const domainKeys = Object.keys(requirements);\n        this.keys = domainKeys.reduce<Record<string, string>>((keys, domain) => {\n            keys[domain] = domain;\n            return keys;\n        }, {}) as DomainKeys<R>;\n        return new Proxy(this, {\n            get(target, prop, receiver) { // prop = domain\n                return ((typeof prop === \"string\") && domainKeys.includes(prop))\n                    ? new UsecaseSelector<R, StringKeyof<R>>(prop as StringKeyof<R>, requirements[prop])\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <R extends DomainRequirements>(requirements: R) => Robustive<R>;\n\nexport type AllUsecases<R extends DomainRequirements, D extends keyof R> = {\n    [U in keyof R[D]] : Usecase<R, D, U>\n}[keyof R[D]];\n\nexport type AllUsecasesOverDomain<R extends DomainRequirements> = {\n    [D in keyof R] : {\n        [U in keyof R[D]] : Usecase<R, D, U>\n    }[keyof R[D]]\n}[keyof R];\n\nexport class ActorNotAuthorizedToInteractIn<A extends IActor<NOCARE>, Domain, Usecase> extends Error {\n    constructor(actor: A, domain: Domain, usecase: Usecase) {\n        super(`The actor \"${ actor.constructor.name }\" is not authorized to interact on usecase \"${ String(usecase) }\" of domain \"${ String(domain) }\".`);\n    }\n}","import { Empty } from \"./usecase\";\n\ntype CaseWithAssociatedValues = Record<string, object>\n\ntype KeyFactory<T extends CaseWithAssociatedValues> = {\n    [K in keyof T]: K\n}\n\nconst KeyFactory = class KeyFactory {\n    constructor() {\n        return new Proxy(this, {\n            get(target, prop, receiver) { // prop = scene\n                return ((typeof prop === \"string\") && !(prop in target))\n                    ? prop\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <T extends CaseWithAssociatedValues>() => KeyFactory<T>;\n  \n\ntype SwiftEnumCase<T extends CaseWithAssociatedValues, K extends keyof T, U > = U & (T[K] extends Empty ? { readonly case: K } : { readonly case: K } & T[K])\n\nexport type SwiftEnumCases<T extends CaseWithAssociatedValues, U = Empty> = {\n    readonly [K in keyof T]: SwiftEnumCase<T, K, U>\n}[keyof T]\n\nexport type SwiftEnum<T extends CaseWithAssociatedValues, U> = {\n    [K in keyof T]: T[K] extends Empty\n        ? () => SwiftEnumCase<T, K, U>\n        : (associatedValues: T[K]) => SwiftEnumCase<T, K, U>\n} & { keys: KeyFactory<T> }\n\nexport const SwiftEnum = class SwiftEnum<T extends CaseWithAssociatedValues, U extends Object> {\n    keys: KeyFactory<T>;\n    constructor(f?: new () => U) {\n        this.keys = new KeyFactory<T>();\n        return new Proxy(this, {\n            get(target, prop, receiver) {\n                return typeof prop === \"string\" && !(prop in target)\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    ? (associatedValues?: any) =>\n                        f !== undefined\n                            /**\n                             * note: Thereâ€™s room for discussion on whether to restrict associatedValues \n                             * to an Object and use `{ ...associatedValues }`, or to allow class instances \n                             * by using `associatedValues || {}`.\n                             * The former eliminates the risk of mutating the original reference, \n                             * but at the cost of losing the flexibility to pass in instances.\n                             */\n                            ? Object.freeze(Object.assign(new f(), Object.assign(associatedValues || {}, { case: prop })))\n                            : Object.freeze(Object.assign(associatedValues || {}, { case: prop }))\n                    : Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n} as new <T extends CaseWithAssociatedValues, U = Empty>(\n    f?: new () => U\n) => SwiftEnum<T, U>;\n"],"names":["AbstractActor","user","Nobody","isNobody","actor","SceneFactory","target","prop","receiver","ContextFactory","course","withValues","SceneFactoryAdapter","Scenario","domain","usecase","id","to","next","withResult","InteractResultType","InteractResultFactory","generateId","length","S","n","currentContextStore","UsecaseImple","initialContext","scenario","context","delegate","err","ActorNotAuthorizedToInteractIn","nextScene","startAt","InteractResult","recursive","lastScene","performedScenario","endAt","elapsedTimeMs","lastSceneContext","result","ScenarioFactory","_id","s","usecaseImple","CourseSelector","UsecaseSelector","scenarioConstructors","usecaseKeys","keys","Robustive","requirements","domainKeys","KeyFactory","SwiftEnum","f","associatedValues"],"mappings":"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"}