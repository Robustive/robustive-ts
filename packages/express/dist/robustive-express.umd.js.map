{"version":3,"file":"robustive-express.umd.js","sources":["../src/index.ts"],"sourcesContent":["import {\n    Scenario,\n    UsecaseImple,\n    Context,\n    Scenes,\n    IActor,\n    InferScenes,\n    DomainRequirements,\n    NOCARE,\n    Empty,\n    SwiftEnum,\n    SwiftEnumCases,\n    ActorNotAuthorizedToInteractIn\n} from \"robustive-ts\";\nimport { Request, Response } from \"express\";\nimport { AsyncLocalStorage } from \"node:async_hooks\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Self = any;\n\ntype ResponseStatusContext = {\n    normal: { statusCode: number; }\n    responded: Empty\n}\n\nexport const ResponseStatus = new SwiftEnum<ResponseStatusContext>();\nexport type ResponseStatus = SwiftEnumCases<ResponseStatusContext>;\n\nexport type ResponseContext<Z extends Scenes> = Context<Z> & { status?: ResponseStatus };\n\ndeclare module \"robustive-ts\" {\n    interface IScenarioDelegate<Z extends Scenes> {\n        proceedUntilResponse?<A extends IActor<NOCARE>, S extends Scenario<Z>>(req: Request, res: Response, to: Context<Z>, actor: A, scenario: S): Promise<ResponseContext<Z>>;\n        /**\n         * When set, it will be executed after exiting the recursive handleRequest. Please use this to ensure that no cleanup or finalization steps within the use case are missed.\n         */\n        gracefullyComplete?(where: string): Promise<void>;\n    }\n\n    interface Scenario<Z extends Scenes> {\n        proceedUntilResponse<A extends IActor<NOCARE>>(req: Request, res: Response, to: Context<Z>, actor: A): Promise<ResponseContext<Z>>;\n        respond(next: Context<Z>, status?: ResponseStatus): Promise<ResponseContext<Z>>;\n    }\n\n    interface UsecaseImple<R extends DomainRequirements, D extends keyof R, U extends keyof R[D]> {\n        handleRequest<User, A extends IActor<User>>(req: Request, res: Response, actor: A): Promise<ResponseContext<InferScenes<R, D, U>>>;\n    }\n}\n\nScenario.prototype.proceedUntilResponse = function <Z extends Scenes, A extends IActor<NOCARE>>(\n    this: Scenario<Z>,\n    req: Request,\n    res: Response,\n    to: Context<Z>,\n    actor: A\n): Promise<ResponseContext<Z>> {\n    if (this.delegate !== undefined && this.delegate.proceedUntilResponse !== undefined) {\n        return this.delegate.proceedUntilResponse(req, res, to, actor, this);\n    }\n    return Promise.reject(new Error());\n};\n\nScenario.prototype.respond = function <Z extends Scenes>(\n    this: Scenario<Z>,\n    next: Context<Z>,\n    status: ResponseStatus = ResponseStatus.normal({ statusCode: 200 })\n): Promise<ResponseContext<Z>> {\n    return Promise.resolve({ ...next, status });\n};\n\n/**\n * By passing an AsyncLocalStorage instance and an initial value to the als and defaultContext arguments, the values stored in AsyncLocalStorage become available as the execution context during the use case.\n */\nUsecaseImple.prototype.handleRequest = function <R extends DomainRequirements, D extends keyof R, U extends keyof R[D], User, A extends IActor<User>, T extends object>(\n    this: UsecaseImple<R, D, U>,\n    req: Request,\n    res: Response,\n    actor: A,\n    als?: AsyncLocalStorage<T>,\n    defaultContext?: T\n): Promise<ResponseContext<InferScenes<R, D, U>>> {\n    const self = this as Self;\n    const recursive = (req: Request, res: Response, scenario: ResponseContext<InferScenes<R, D, U>>[]): Promise<ResponseContext<InferScenes<R, D, U>>> => {\n        const lastScene = scenario.slice(-1)[0];\n        if (lastScene.course === \"goals\" || lastScene.status) { // exit criteria\n            return Promise.resolve(lastScene);\n        }\n\n        return self._scenario.proceedUntilResponse(req, res, lastScene, actor)\n            .then((nextScene: ResponseContext<InferScenes<R, D, U>>) => {\n                self.currentContext = nextScene;\n                scenario.push(nextScene);\n                return recursive(req, res, scenario);\n            });\n    };\n\n    if (self._scenario.authorize && !self._scenario.authorize(actor, self._domain as Extract<D, string>, self._usecase as Extract<U, string>)) {\n        const err = new ActorNotAuthorizedToInteractIn(actor, self._domain, self._usecase);\n        return Promise.reject(err);\n    }\n\n    const scenario: ResponseContext<InferScenes<R, D, U>>[] = [self.currentContext as ResponseContext<InferScenes<R, D, U>>];\n\n    if (als) {\n        return als.run(defaultContext ?? {} as T, async () => {\n            try {\n                return await recursive(req, res, scenario);\n            } finally {\n                await self._scenario.delegate?.gracefullyComplete?.(\"handleRequest.finally\");\n            }\n        });\n    } else {\n        return recursive(req, res, scenario);\n    }\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n} as any;"],"names":["ResponseStatus","SwiftEnum","Scenario","req","res","to","actor","robustiveTs","next","status","UsecaseImple","als","defaultContext","self","recursive","scenario","lastScene","nextScene","err","ActorNotAuthorizedToInteractIn","_b","_a"],"mappings":"+SAyBa,MAAAA,EAAiB,IAAIC,EAAAA,UAwBlCC,EAAAA,SAAS,UAAU,qBAAuB,SAEtCC,EACAC,EACAC,EACAC,EAC2B,CAC3B,OAAI,KAAK,WAAa,QAAa,KAAK,SAAS,uBAAyB,OAC/D,KAAK,SAAS,qBAAqBH,EAAKC,EAAKC,EAAIC,EAAO,IAAI,EAEhE,QAAQ,OAAO,IAAI,KAAO,CACrC,EAESC,EAAA,SAAA,UAAU,QAAU,SAEzBC,EACAC,EAAyBT,EAAe,OAAO,CAAE,WAAY,GAAI,CAAC,EACvC,CAC3B,OAAO,QAAQ,QAAQ,CAAE,GAAGQ,EAAM,OAAAC,CAAQ,CAAA,CAC9C,EAKAC,EAAAA,aAAa,UAAU,cAAgB,SAEnCP,EACAC,EACAE,EACAK,EACAC,EAC8C,CAC9C,MAAMC,EAAO,KACPC,EAAY,CAACX,EAAcC,EAAeW,IAAsG,CAClJ,MAAMC,EAAYD,EAAS,MAAM,EAAE,EAAE,GACrC,OAAIC,EAAU,SAAW,SAAWA,EAAU,OACnC,QAAQ,QAAQA,CAAS,EAG7BH,EAAK,UAAU,qBAAqBV,EAAKC,EAAKY,EAAWV,CAAK,EAChE,KAAMW,IACHJ,EAAK,eAAiBI,EACtBF,EAAS,KAAKE,CAAS,EAChBH,EAAUX,EAAKC,EAAKW,CAAQ,EACtC,CAAA,EAGT,GAAIF,EAAK,UAAU,WAAa,CAACA,EAAK,UAAU,UAAUP,EAAOO,EAAK,QAA+BA,EAAK,QAA8B,EAAG,CACvI,MAAMK,EAAM,IAAIC,EAAAA,+BAA+Bb,EAAOO,EAAK,QAASA,EAAK,QAAQ,EAC1E,OAAA,QAAQ,OAAOK,CAAG,CAC7B,CAEM,MAAAH,EAAoD,CAACF,EAAK,cAAuD,EAEvH,OAAIF,EACOA,EAAI,IAAIC,GAAA,KAAAA,EAAkB,GAAS,SAAY,SAC9C,GAAA,CACA,OAAO,MAAME,EAAUX,EAAKC,EAAKW,CAAQ,CAAA,QAC3C,CACE,OAAMK,GAAAC,EAAAR,EAAK,UAAU,WAAf,YAAAQ,EAAyB,qBAAzB,YAAAD,EAAA,KAAAC,EAA8C,yBACxD,CAAA,CACH,EAEMP,EAAUX,EAAKC,EAAKW,CAAQ,CAG3C"}