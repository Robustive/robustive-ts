{"version":3,"file":"robustive-express.es.js","sources":["../src/index.ts"],"sourcesContent":["import {\n    Scenario,\n    UsecaseImple,\n    Context,\n    Scenes,\n    IActor,\n    InferScenes,\n    DomainRequirements,\n    NOCARE,\n    Empty,\n    SwiftEnum,\n    SwiftEnumCases,\n    ActorNotAuthorizedToInteractIn,\n    StringKeyof,\n} from \"@robustive/robustive-ts\";\nimport { Request, Response } from \"express\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Self = any;\n\ntype ResponseStatusContext = {\n    normal: { statusCode: number; }\n    responded: Empty\n}\n\nexport const ResponseStatus = new SwiftEnum<ResponseStatusContext>();\nexport type ResponseStatus = SwiftEnumCases<ResponseStatusContext>;\n\nexport type ResponseContext<Z extends Scenes> = Context<Z> & { status?: ResponseStatus };\n\ndeclare module \"@robustive/robustive-ts\" {\n    interface IScenarioDelegate<Z extends Scenes> {\n        validateHttpMethod?<R extends DomainRequirements, D extends StringKeyof<R>, U extends StringKeyof<R[D]>>(domain: D, usecase: U, method: string): boolean;\n        proceedUntilResponse?<A extends IActor<NOCARE>, S extends Scenario<Z>>(req: Request, res: Response, to: Context<Z>, actor: A, scenario: S): Promise<ResponseContext<Z>>;\n    }\n\n    interface Scenario<Z extends Scenes> {\n        validateHttpMethod<R extends DomainRequirements, D extends StringKeyof<R>, U extends StringKeyof<R[D]>>(domain: D, usecase: U, method: string): boolean;\n        proceedUntilResponse<A extends IActor<NOCARE>>(req: Request, res: Response, to: Context<Z>, actor: A): Promise<ResponseContext<Z>>;\n        respond(next: Context<Z>, status?: ResponseStatus): Promise<ResponseContext<Z>>;\n    }\n\n    interface UsecaseImple<R extends DomainRequirements, D extends keyof R, U extends keyof R[D]> {\n        handleRequest<User, A extends IActor<User>>(req: Request, res: Response, actor: A, recursiveWrapper?: (recursive: () => Promise<HandleResult<R, D, U, A, InferScenes<R, D, U>>>) => Promise<HandleResult<R, D, U, A, InferScenes<R, D, U>>>): Promise<HandleResult<R, D, U, A, InferScenes<R, D, U>>>;\n    }\n}\n\nexport class HttpMethodIsNotAuthorized<Domain, Usecase> extends Error {\n    constructor(domain: Domain, usecase: Usecase, method: string) {\n        super(`\"${ method }\" is not authorized to proceed usecase \"${ String(usecase) }\" of domain \"${ String(domain) }\".`);\n        this.name = \"HttpMethodIsNotAuthorized\";\n    }\n}\n\nScenario.prototype.validateHttpMethod = function <Z extends Scenes, R extends DomainRequirements, D extends StringKeyof<R>, U extends StringKeyof<R[D]>>(\n    this: Scenario<Z>,\n    domain: D,\n    usecase: U,\n    method: string\n): boolean {\n    if (this.delegate !== undefined && this.delegate.validateHttpMethod !== undefined) {\n        return this.delegate.validateHttpMethod(domain, usecase, method);\n    }\n    return true;\n};\n\nScenario.prototype.proceedUntilResponse = function <Z extends Scenes, A extends IActor<NOCARE>>(\n    this: Scenario<Z>,\n    req: Request,\n    res: Response,\n    to: Context<Z>,\n    actor: A\n): Promise<ResponseContext<Z>> {\n    if (this.delegate !== undefined && this.delegate.proceedUntilResponse !== undefined) {\n        return this.delegate.proceedUntilResponse(req, res, to, actor, this);\n    }\n    return Promise.reject(new Error());\n};\n\nScenario.prototype.respond = function <Z extends Scenes>(\n    this: Scenario<Z>,\n    next: Context<Z>,\n    status: ResponseStatus = ResponseStatus.normal({ statusCode: 200 })\n): Promise<ResponseContext<Z>> {\n    return Promise.resolve({ ...next, status });\n};\n\nexport const HandleResultType = {\n    success: \"success\"\n    , failure: \"failure\"\n} as const;\n\ntype HandleResultContext<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends Scenes> = {\n    [HandleResultType.success] : {\n        id: string;\n        actor : A;\n        domain : D;\n        usecase : U;\n        startAt : Date;\n        endAt : Date;\n        elapsedTimeMs : number;\n        performedScenario : ResponseContext<Z>[];\n        lastSceneContext : ResponseContext<Z>;\n    };\n    [HandleResultType.failure] : {\n        id: string;\n        actor : A;\n        domain : D;\n        usecase : U;\n        startAt : Date;\n        endAt : Date;\n        elapsedTimeMs : number;\n        performedScenario : ResponseContext<Z>[];\n        failedSceneContext : ResponseContext<Z>;\n        error: Error;\n    };\n};\n\ntype HandleResultCase<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends Scenes, K extends keyof HandleResultContext<R, D, U, A, Z>> = Record<\"type\", K> & HandleResultContext<R, D, U, A, Z>[K];\n\nexport type HandleResult<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends Scenes> = { \n    [K in keyof HandleResultContext<R, D, U, A, Z>] : HandleResultCase<R, D, U, A, Z, K>;\n}[keyof HandleResultContext<R, D, U, A, Z>];\n\n/**\n * @param recursiveWrapper An optional function to wrap the recursive calls. Useful for integrating with async context tracking.\n */\nUsecaseImple.prototype.handleRequest = function <R extends DomainRequirements, D extends keyof R, U extends keyof R[D], User, A extends IActor<User>, T extends object>(\n    this: UsecaseImple<R, D, U>,\n    req: Request,\n    res: Response,\n    actor: A,\n    recursiveWrapper?: (recursive: () => Promise<HandleResult<R, D, U, A, InferScenes<R, D, U>>>) => Promise<HandleResult<R, D, U, A, InferScenes<R, D, U>>>\n): Promise<HandleResult<R, D, U, A, InferScenes<R, D, U>>> {\n    const self = this as Self;\n    const startAt = new Date();\n    const recursive = (req: Request, res: Response, scenario: ResponseContext<InferScenes<R, D, U>>[]): Promise<ResponseContext<InferScenes<R, D, U>>[]> => {\n        const lastScene = scenario.slice(-1)[0];\n        if (lastScene.course === \"goals\" || lastScene.status) { // exit criteria\n            return Promise.resolve(scenario);\n        }\n\n        return self._scenario.proceedUntilResponse(req, res, lastScene, actor)\n            .then((nextScene: ResponseContext<InferScenes<R, D, U>>) => {\n                self.currentContext = nextScene;\n                scenario.push(nextScene);\n                return recursive(req, res, scenario);\n            });\n    };\n\n    if (self._scenario.authorize && !self._scenario.authorize(actor, self._domain as Extract<D, string>, self._usecase as Extract<U, string>)) {\n        const err = new ActorNotAuthorizedToInteractIn(actor, self._domain, self._usecase);\n        return Promise.reject(err);\n    }\n\n    if (self._scenario.validateHttpMethod && !self._scenario.validateHttpMethod(self._domain, self._usecase, req.method)) {\n        const err = new HttpMethodIsNotAuthorized(self._domain, self._usecase, req.method);\n        return Promise.reject(err);\n    }\n\n    const scenario: ResponseContext<InferScenes<R, D, U>>[] = [self.currentContext as ResponseContext<InferScenes<R, D, U>>];\n\n    const execRecursion = () => recursive(req, res, scenario)\n        .then((performedScenario) => {\n            const endAt = new Date();\n            const elapsedTimeMs = (endAt.getTime() - startAt.getTime());\n            const lastSceneContext = performedScenario.slice(-1)[0];\n            return {\n                type: HandleResultType.success\n                , id: self.id\n                , actor\n                , domain: self._domain\n                , usecase : self._usecase\n                , startAt\n                , endAt\n                , elapsedTimeMs\n                , performedScenario\n                , lastSceneContext\n            } as HandleResultCase<R, D, U, A, InferScenes<R, D, U>, \"success\">;\n        })\n        .catch((error: Error) => {\n            const endAt = new Date();\n            const elapsedTimeMs = (endAt.getTime() - startAt.getTime());\n            const lastSceneContext = scenario.slice(-1)[0];\n            return {\n                type: HandleResultType.failure\n                , id: self.id\n                , actor\n                , domain: self._domain\n                , usecase : self._usecase\n                , startAt\n                , endAt\n                , elapsedTimeMs\n                , performedScenario : scenario\n                , failedSceneContext : lastSceneContext\n                , error\n            } as HandleResultCase<R, D, U, A, InferScenes<R, D, U>, \"failure\">;\n        });\n\n    if (recursiveWrapper) {\n        return recursiveWrapper(execRecursion);\n    } else {\n        return execRecursion();\n    }\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n} as any;"],"names":["req","res","scenario"],"mappings":"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"}