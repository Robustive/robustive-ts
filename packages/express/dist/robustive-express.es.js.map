{"version":3,"file":"robustive-express.es.js","sources":["../../core/dist/robustive.es.js","../src/index.ts"],"sourcesContent":["class AbstractActor {\n  constructor(user = null) {\n    this.user = user;\n  }\n}\nclass Nobody extends AbstractActor {\n}\nconst isNobody = (actor) => actor.constructor === Nobody;\nconst SceneFactory = class SceneFactory2 {\n  constructor() {\n    return new Proxy(this, {\n      get(target, prop, receiver) {\n        return typeof prop === \"string\" && !(prop in target) ? prop : Reflect.get(target, prop, receiver);\n      }\n    });\n  }\n};\nconst ContextFactory = class ContextFactory2 {\n  constructor(course) {\n    return new Proxy(this, {\n      get(target, prop, receiver) {\n        return typeof prop === \"string\" && !(prop in target) ? (withValues) => {\n          return Object.freeze(Object.assign(withValues || {}, { \"scene\": prop, course }));\n        } : Reflect.get(target, prop, receiver);\n      }\n    });\n  }\n};\nconst SceneFactoryAdapter = class SceneFactoryAdapter2 {\n  constructor() {\n    return new Proxy(this, {\n      get(target, prop, receiver) {\n        return typeof prop === \"string\" && !(prop in target) ? prop : Reflect.get(target, prop, receiver);\n      }\n    });\n  }\n};\nclass Scenario {\n  constructor(domain, usecase, id) {\n    this.domain = domain;\n    this.usecase = usecase;\n    this.id = id;\n    this.keys = {\n      basics: new SceneFactory(),\n      alternatives: new SceneFactory(),\n      goals: new SceneFactory()\n    };\n    this.basics = new ContextFactory(\"basics\");\n    this.alternatives = new ContextFactory(\"alternatives\");\n    this.goals = new ContextFactory(\"goals\");\n  }\n  next(to, actor) {\n    if (this.delegate !== void 0 && this.delegate.next !== void 0) {\n      return this.delegate.next(to, actor, this);\n    }\n    return Promise.reject(new Error());\n  }\n  just(next) {\n    return Promise.resolve(next);\n  }\n  authorize(actor, domain, usecase) {\n    if (this.delegate !== void 0 && this.delegate.authorize !== void 0) {\n      return this.delegate.authorize(actor, domain, usecase);\n    }\n    throw new Error(`USECASE \"${usecase}\" IS NOT AUTHORIZED FOR ACTOR \"${actor.constructor.name}.\"`);\n  }\n  complete(withResult) {\n    if (this.delegate !== void 0 && this.delegate.complete !== void 0) {\n      this.delegate.complete(withResult);\n    }\n  }\n}\nconst InteractResultType = {\n  success: \"success\",\n  failure: \"failure\"\n};\nconst InteractResultFactory = class InteractResultFactory2 {\n  constructor() {\n    return new Proxy(this, {\n      get(target, prop, receiver) {\n        return typeof prop === \"string\" && !(prop in target) ? (withValues) => {\n          return Object.freeze(Object.assign(withValues, { \"type\": prop }));\n        } : Reflect.get(target, prop, receiver);\n      }\n    });\n  }\n};\nconst generateId = (length) => {\n  const S = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n  return Array.from(crypto.getRandomValues(new Uint8Array(length))).map((n) => S[n % S.length]).join(\"\");\n};\nconst currentContextStore = /* @__PURE__ */ new WeakMap();\nclass UsecaseImple {\n  constructor(id, domain, usecase, initialContext, scenario) {\n    this.id = id;\n    this._domain = domain;\n    this._usecase = usecase;\n    this._scenario = scenario;\n    currentContextStore.set(this, initialContext);\n  }\n  get currentContext() {\n    return currentContextStore.get(this);\n  }\n  set currentContext(context) {\n    currentContextStore.set(this, context);\n  }\n  set(delegate) {\n    this._scenario.delegate = delegate;\n  }\n  progress(actor) {\n    if (this._scenario.authorize && !this._scenario.authorize(actor, this._domain, this._usecase)) {\n      const err = new ActorNotAuthorizedToInteractIn(actor, this._domain, this._usecase);\n      return Promise.reject(err);\n    }\n    return this._scenario.next(this.currentContext, actor).then((nextScene) => {\n      this.currentContext = nextScene;\n      return nextScene;\n    });\n  }\n  interactedBy(actor) {\n    const startAt = new Date();\n    const InteractResult = new InteractResultFactory();\n    const recursive = (scenario2) => {\n      const lastScene = scenario2.slice(-1)[0];\n      if (lastScene.course === \"goals\") {\n        return Promise.resolve(scenario2);\n      }\n      return this._scenario.next(lastScene, actor).then((nextScene) => {\n        this.currentContext = nextScene;\n        scenario2.push(nextScene);\n        return recursive(scenario2);\n      });\n    };\n    if (this._scenario.authorize && !this._scenario.authorize(actor, this._domain, this._usecase)) {\n      const err = new ActorNotAuthorizedToInteractIn(actor, this._domain, this._usecase);\n      return Promise.reject(err);\n    }\n    const scenario = [this.currentContext];\n    return recursive(scenario).then((performedScenario) => {\n      const endAt = new Date();\n      const elapsedTimeMs = endAt.getTime() - startAt.getTime();\n      const lastSceneContext = performedScenario.slice(-1)[0];\n      const result = InteractResult.success({\n        id: this.id,\n        actor,\n        domain: this._domain,\n        usecase: this._usecase,\n        startAt,\n        endAt,\n        elapsedTimeMs,\n        performedScenario,\n        lastSceneContext\n      });\n      if (this._scenario.complete) {\n        this._scenario.complete(result);\n      }\n      return result;\n    }).catch((error) => {\n      console.error(error);\n      const endAt = new Date();\n      const elapsedTimeMs = endAt.getTime() - startAt.getTime();\n      const lastSceneContext = scenario.slice(-1)[0];\n      const result = InteractResult.failure({\n        id: this.id,\n        actor,\n        domain: this._domain,\n        usecase: this._usecase,\n        startAt,\n        endAt,\n        elapsedTimeMs,\n        performedScenario: scenario,\n        failedSceneContext: lastSceneContext,\n        error\n      });\n      if (this._scenario.complete) {\n        this._scenario.complete(result);\n      }\n      return result;\n    });\n  }\n}\nconst ScenarioFactory = class ScenarioFactory2 {\n  constructor(domain, usecase, course, scenario) {\n    return new Proxy(this, {\n      get(target, prop, receiver) {\n        return typeof prop === \"string\" && !(prop in target) ? (withValues, id) => {\n          const context = Object.assign(withValues || {}, { \"scene\": prop, course });\n          const _id = id || generateId(8);\n          const s = new scenario(domain, usecase, _id);\n          const usecaseImple = new UsecaseImple(_id, domain, usecase, context, s);\n          return Object.freeze(Object.assign(usecaseImple, { \"domain\": domain, \"name\": usecase, \"scene\": prop, course }));\n        } : Reflect.get(target, prop, receiver);\n      }\n    });\n  }\n};\nclass CourseSelector {\n  constructor(domain, usecase, scenario) {\n    this.keys = {\n      basics: new SceneFactoryAdapter(),\n      alternatives: new SceneFactoryAdapter(),\n      goals: new SceneFactoryAdapter()\n    };\n    this.basics = new ScenarioFactory(domain, usecase, \"basics\", scenario);\n    this.alternatives = new ScenarioFactory(domain, usecase, \"alternatives\", scenario);\n    this.goals = new ScenarioFactory(domain, usecase, \"goals\", scenario);\n  }\n}\nconst UsecaseSelector = class UsecaseSelector2 {\n  constructor(domain, scenarioConstructors) {\n    const usecaseKeys = Object.keys(scenarioConstructors);\n    this.keys = usecaseKeys.reduce((keys, usecase) => {\n      keys[usecase] = usecase;\n      return keys;\n    }, {});\n    return new Proxy(this, {\n      get(target, prop, receiver) {\n        return typeof prop === \"string\" && usecaseKeys.includes(prop) ? new CourseSelector(domain, prop, scenarioConstructors[prop]) : Reflect.get(target, prop, receiver);\n      }\n    });\n  }\n};\nconst Robustive = class Robustive2 {\n  constructor(requirements) {\n    const domainKeys = Object.keys(requirements);\n    this.keys = domainKeys.reduce((keys, domain) => {\n      keys[domain] = domain;\n      return keys;\n    }, {});\n    return new Proxy(this, {\n      get(target, prop, receiver) {\n        return typeof prop === \"string\" && domainKeys.includes(prop) ? new UsecaseSelector(prop, requirements[prop]) : Reflect.get(target, prop, receiver);\n      }\n    });\n  }\n};\nclass ActorNotAuthorizedToInteractIn extends Error {\n  constructor(actor, domain, usecase) {\n    super(`The actor \"${actor.constructor.name}\" is not authorized to interact on usecase \"${String(usecase)}\" of domain \"${String(domain)}\".`);\n  }\n}\nconst KeyFactory = class KeyFactory2 {\n  constructor() {\n    return new Proxy(this, {\n      get(target, prop, receiver) {\n        return typeof prop === \"string\" && !(prop in target) ? prop : Reflect.get(target, prop, receiver);\n      }\n    });\n  }\n};\nconst SwiftEnum = class SwiftEnum2 {\n  constructor(f) {\n    this.keys = new KeyFactory();\n    return new Proxy(this, {\n      get(target, prop, receiver) {\n        return typeof prop === \"string\" && !(prop in target) ? (associatedValues) => f !== void 0 ? Object.freeze(Object.assign(new f(), Object.assign(associatedValues || {}, { case: prop }))) : Object.freeze(Object.assign(associatedValues || {}, { case: prop })) : Reflect.get(target, prop, receiver);\n      }\n    });\n  }\n};\nexport { AbstractActor, ActorNotAuthorizedToInteractIn, CourseSelector, InteractResultType, Nobody, Robustive, Scenario, SwiftEnum, UsecaseImple, UsecaseSelector, isNobody };\n//# sourceMappingURL=robustive.es.js.map\n","import {\n    Scenario,\n    UsecaseImple,\n    Context,\n    Scenes,\n    IActor,\n    InferScenes,\n    DomainRequirements,\n    NOCARE,\n    Empty,\n    SwiftEnum,\n    SwiftEnumCases,\n    ActorNotAuthorizedToInteractIn,\n} from \"@robustive/robustive-ts\";\nimport { Request, Response } from \"express\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Self = any;\n\ntype ResponseStatusContext = {\n    normal: { statusCode: number; }\n    responded: Empty\n}\n\nexport const ResponseStatus = new SwiftEnum<ResponseStatusContext>();\nexport type ResponseStatus = SwiftEnumCases<ResponseStatusContext>;\n\nexport type ResponseContext<Z extends Scenes> = Context<Z> & { status?: ResponseStatus };\n\ndeclare module \"@robustive/robustive-ts\" {\n    interface IScenarioDelegate<Z extends Scenes> {\n        proceedUntilResponse?<A extends IActor<NOCARE>, S extends Scenario<Z>>(req: Request, res: Response, to: Context<Z>, actor: A, scenario: S): Promise<ResponseContext<Z>>;\n    }\n\n    interface Scenario<Z extends Scenes> {\n        proceedUntilResponse<A extends IActor<NOCARE>>(req: Request, res: Response, to: Context<Z>, actor: A): Promise<ResponseContext<Z>>;\n        respond(next: Context<Z>, status?: ResponseStatus): Promise<ResponseContext<Z>>;\n    }\n\n    interface UsecaseImple<R extends DomainRequirements, D extends keyof R, U extends keyof R[D]> {\n        handleRequest<User, A extends IActor<User>>(req: Request, res: Response, actor: A, recursiveWrapper?: (recursive: () => Promise<HandleResult<R, D, U, A, InferScenes<R, D, U>>>) => Promise<HandleResult<R, D, U, A, InferScenes<R, D, U>>>): Promise<HandleResult<R, D, U, A, InferScenes<R, D, U>>>;\n    }\n}\n\nScenario.prototype.proceedUntilResponse = function <Z extends Scenes, A extends IActor<NOCARE>>(\n    this: Scenario<Z>,\n    req: Request,\n    res: Response,\n    to: Context<Z>,\n    actor: A\n): Promise<ResponseContext<Z>> {\n    if (this.delegate !== undefined && this.delegate.proceedUntilResponse !== undefined) {\n        return this.delegate.proceedUntilResponse(req, res, to, actor, this);\n    }\n    return Promise.reject(new Error());\n};\n\nScenario.prototype.respond = function <Z extends Scenes>(\n    this: Scenario<Z>,\n    next: Context<Z>,\n    status: ResponseStatus = ResponseStatus.normal({ statusCode: 200 })\n): Promise<ResponseContext<Z>> {\n    return Promise.resolve({ ...next, status });\n};\n\nexport const HandleResultType = {\n    success: \"success\"\n    , failure: \"failure\"\n} as const;\n\ntype HandleResultContext<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends Scenes> = {\n    [HandleResultType.success] : {\n        id: string;\n        actor : A;\n        domain : D;\n        usecase : U;\n        startAt : Date;\n        endAt : Date;\n        elapsedTimeMs : number;\n        performedScenario : ResponseContext<Z>[];\n        lastSceneContext : ResponseContext<Z>;\n    };\n    [HandleResultType.failure] : {\n        id: string;\n        actor : A;\n        domain : D;\n        usecase : U;\n        startAt : Date;\n        endAt : Date;\n        elapsedTimeMs : number;\n        performedScenario : ResponseContext<Z>[];\n        failedSceneContext : ResponseContext<Z>;\n        error: Error;\n    };\n};\n\ntype HandleResultCase<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends Scenes, K extends keyof HandleResultContext<R, D, U, A, Z>> = Record<\"type\", K> & HandleResultContext<R, D, U, A, Z>[K];\n\nexport type HandleResult<R extends DomainRequirements, D extends keyof R, U extends keyof R[D], A extends IActor<NOCARE>, Z extends Scenes> = { \n    [K in keyof HandleResultContext<R, D, U, A, Z>] : HandleResultCase<R, D, U, A, Z, K>;\n}[keyof HandleResultContext<R, D, U, A, Z>];\n\n/**\n * @param recursiveWrapper An optional function to wrap the recursive calls. Useful for integrating with async context tracking.\n */\nUsecaseImple.prototype.handleRequest = function <R extends DomainRequirements, D extends keyof R, U extends keyof R[D], User, A extends IActor<User>, T extends object>(\n    this: UsecaseImple<R, D, U>,\n    req: Request,\n    res: Response,\n    actor: A,\n    recursiveWrapper?: (recursive: () => Promise<HandleResult<R, D, U, A, InferScenes<R, D, U>>>) => Promise<HandleResult<R, D, U, A, InferScenes<R, D, U>>>\n): Promise<HandleResult<R, D, U, A, InferScenes<R, D, U>>> {\n    const self = this as Self;\n    const startAt = new Date();\n    const recursive = (req: Request, res: Response, scenario: ResponseContext<InferScenes<R, D, U>>[]): Promise<ResponseContext<InferScenes<R, D, U>>[]> => {\n        const lastScene = scenario.slice(-1)[0];\n        if (lastScene.course === \"goals\" || lastScene.status) { // exit criteria\n            return Promise.resolve(scenario);\n        }\n\n        return self._scenario.proceedUntilResponse(req, res, lastScene, actor)\n            .then((nextScene: ResponseContext<InferScenes<R, D, U>>) => {\n                self.currentContext = nextScene;\n                scenario.push(nextScene);\n                return recursive(req, res, scenario);\n            });\n    };\n\n    if (self._scenario.authorize && !self._scenario.authorize(actor, self._domain as Extract<D, string>, self._usecase as Extract<U, string>)) {\n        const err = new ActorNotAuthorizedToInteractIn(actor, self._domain, self._usecase);\n        return Promise.reject(err);\n    }\n\n    const scenario: ResponseContext<InferScenes<R, D, U>>[] = [self.currentContext as ResponseContext<InferScenes<R, D, U>>];\n\n    const execRecursion = () => recursive(req, res, scenario)\n        .then((performedScenario) => {\n            const endAt = new Date();\n            const elapsedTimeMs = (endAt.getTime() - startAt.getTime());\n            const lastSceneContext = performedScenario.slice(-1)[0];\n            return {\n                type: HandleResultType.success\n                , id: self.id\n                , actor\n                , domain: self._domain\n                , usecase : self._usecase\n                , startAt\n                , endAt\n                , elapsedTimeMs\n                , performedScenario\n                , lastSceneContext\n            } as HandleResultCase<R, D, U, A, InferScenes<R, D, U>, \"success\">;\n        })\n        .catch((error: Error) => {\n            const endAt = new Date();\n            const elapsedTimeMs = (endAt.getTime() - startAt.getTime());\n            const lastSceneContext = scenario.slice(-1)[0];\n            return {\n                type: HandleResultType.failure\n                , id: self.id\n                , actor\n                , domain: self._domain\n                , usecase : self._usecase\n                , startAt\n                , endAt\n                , elapsedTimeMs\n                , performedScenario : scenario\n                , failedSceneContext : lastSceneContext\n                , error\n            } as HandleResultCase<R, D, U, A, InferScenes<R, D, U>, \"failure\">;\n        });\n\n    if (recursiveWrapper) {\n        return recursiveWrapper(execRecursion);\n    } else {\n        return execRecursion();\n    }\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n} as any;"],"names":["req","res","scenario"],"mappings":"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"}